<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[ML Basics] Linear Algebra | Followb1ind1y</title>
<meta name="keywords" content="Linear Algebra" />
<meta name="description" content="Scalars, Vectors, Matrices and Tensors The study of linear algebra involves several types of mathematical objects:
  Scalars: A scalar is just a single number, in contrast to most of the other objects studied in linear algebra, which are usually arrays of multiple numbers. We write scalars in italics. We usually give scalars lowercase variable names. When we introduce them, we specify what kind of number they are. For example, we might say &ldquo;Let $s \in \mathbb{R}$ be the slope of the line,&rdquo; while defining a real-valued scalar, or &ldquo;Let $n \in \mathbb{N}$ be the number of units, while defining an natural number scalar.">
<meta name="author" content="Followb1ind1y">
<link rel="canonical" href="https://followb1ind1y.github.io/posts/applied_math_and_ml_basics/01_linear_algebra_for_ml/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.e70e973962a3e34880adaea2030c2ba5d772c1d55b6db8842bf38c6db6dae5fd.css" integrity="sha256-5w6XOWKj40iAra6iAwwrpddywdVbbbiEK/OMbbba5f0=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://followb1ind1y.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://followb1ind1y.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://followb1ind1y.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://followb1ind1y.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://followb1ind1y.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.83.1" />
<meta property="og:title" content="[ML Basics] Linear Algebra" />
<meta property="og:description" content="Scalars, Vectors, Matrices and Tensors The study of linear algebra involves several types of mathematical objects:
  Scalars: A scalar is just a single number, in contrast to most of the other objects studied in linear algebra, which are usually arrays of multiple numbers. We write scalars in italics. We usually give scalars lowercase variable names. When we introduce them, we specify what kind of number they are. For example, we might say &ldquo;Let $s \in \mathbb{R}$ be the slope of the line,&rdquo; while defining a real-valued scalar, or &ldquo;Let $n \in \mathbb{N}$ be the number of units, while defining an natural number scalar." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://followb1ind1y.github.io/posts/applied_math_and_ml_basics/01_linear_algebra_for_ml/" /><meta property="og:image" content="https://followb1ind1y.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-23T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-06-23T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://followb1ind1y.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="[ML Basics] Linear Algebra"/>
<meta name="twitter:description" content="Scalars, Vectors, Matrices and Tensors The study of linear algebra involves several types of mathematical objects:
  Scalars: A scalar is just a single number, in contrast to most of the other objects studied in linear algebra, which are usually arrays of multiple numbers. We write scalars in italics. We usually give scalars lowercase variable names. When we introduce them, we specify what kind of number they are. For example, we might say &ldquo;Let $s \in \mathbb{R}$ be the slope of the line,&rdquo; while defining a real-valued scalar, or &ldquo;Let $n \in \mathbb{N}$ be the number of units, while defining an natural number scalar."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://followb1ind1y.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[ML Basics] Linear Algebra",
      "item": "https://followb1ind1y.github.io/posts/applied_math_and_ml_basics/01_linear_algebra_for_ml/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[ML Basics] Linear Algebra",
  "name": "[ML Basics] Linear Algebra",
  "description": "Scalars, Vectors, Matrices and Tensors The study of linear algebra involves several types of mathematical objects:\n  Scalars: A scalar is just a single number, in contrast to most of the other objects studied in linear algebra, which are usually arrays of multiple numbers. We write scalars in italics. We usually give scalars lowercase variable names. When we introduce them, we specify what kind of number they are. For example, we might say \u0026ldquo;Let $s \\in \\mathbb{R}$ be the slope of the line,\u0026rdquo; while defining a real-valued scalar, or \u0026ldquo;Let $n \\in \\mathbb{N}$ be the number of units, while defining an natural number scalar.",
  "keywords": [
    "Linear Algebra"
  ],
  "articleBody": "Scalars, Vectors, Matrices and Tensors The study of linear algebra involves several types of mathematical objects:\n  Scalars: A scalar is just a single number, in contrast to most of the other objects studied in linear algebra, which are usually arrays of multiple numbers. We write scalars in italics. We usually give scalars lowercase variable names. When we introduce them, we specify what kind of number they are. For example, we might say “Let $s \\in \\mathbb{R}$ be the slope of the line,” while defining a real-valued scalar, or “Let $n \\in \\mathbb{N}$ be the number of units, while defining an natural number scalar.\n  Vectors: A vector is an array of numbers. The numbers are arranged in order. We can identify each individual number by its index in that ordering. Typically we give vectors lowercase names in bold typeface, such as $\\mathbf{x}$. The elements of the vector are identified by writing its name in italic typeface, with a subscript. We also need to say what kind of numbers are stored in the vector. If each element is in $\\mathbb{R}$, and the vector has $n$ elements, then the vector lies in the set formed by taking the Cartesian product of $\\mathbb{R}$ $n$ times, denoted as $\\mathbb{R}^{n}$. When we need to explicitly identify the elements of a vector, we write them as a column enclosed in square brackets:\n  $$ \\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ \\vdots \\\\ x_{n} \\\\ \\end{bmatrix} $$\n Matrices: A matrix is a 2-D array of numbers, so each element is identified by two indices instead of just one. We usually give matrices upper-case variable names with bold typeface, such as $\\mathbf{A}$. If a real-valued matrix $\\mathbf{A}$ has a height of $m$ and a width of $n$, then we say that $\\mathbf{A} \\in \\mathbb{R}^{m \\times n}$. We usually identify the elements of a matrix using its name in italic but not bold font, and the indices are listed with separating commas. For example, $A_{1,1}$ is the upper left entry of $\\mathbf{A}$ and $A_{m,n}$ is the bottom right entry. We can identify all of the numbers with vertical coordinate $i$ by writing a “:” for the horizontal coordinate. For example, $A_{i,:}$ denotes the horizontal cross section of $\\mathbf{A}$ with vertical coordinate $i$. This is known as the $i$-th row of $\\mathbf{A}$. Likewise, $A_{:,i}$ is the $i$-th column of $\\mathbf{A}$. When we need to explicitly identify the elements of a matrix, we write them as an array enclosed in square brackets:  $$ \\begin{bmatrix} A_{1,1} \u0026 A_{1,2} \\\\ A_{2,1} \u0026 A_{2,2} \\\\ \\end{bmatrix} $$\n Tensors: In some cases we will need an array with more than two axes. In the general case, an array of numbers arranged on a regular grid with a variable number of axes is known as a tensor. We denote a tensor named “A” with this typeface: $\\mathsf{A}$. We identify the element of $\\mathsf{A}$ at coordinates $(i,j,k)$ by writing $A_{i,j,k}$.   标量(Scalar): 标量是一个单独的数. 向量(Vector): 向量是一列有序排列的数. 矩阵(Matrix): 矩阵是一个二维数组, 其中的每一个元素被两个索引. 张量(Tensor): 张量是一个超过二维的数组.  One important operation on matrices is the transpose. The transpose of a matrix is the mirror image of the matrix across a diagonal line, called the main diagonal, running down and to the right, starting from its upper left corner. We denote the transpose of a matrix $A$ as $A^{T}$, and it is defined such that\n$$ (A^{T})_{i,j} = A_{j,i} $$\n Vectors can be thought of as matrices that contain only one column. The transpose of a vector is therefore a matrix with only one row. Sometimes we define a vector by writing out its elements in the text inline as a row matrix, then using the transpose operator to turn it into a standard column vector, e.g., $x = \\begin{bmatrix} x_{1}, x_{2}, x_{3} \\\\ \\end{bmatrix}^{T}$.\nA scalar can be thought of as a matrix with only a single entry. From this, we can see that a scalar is its own transpose: $a = a^{T}$.\n 转置(Transpose) 是矩阵的一种重要操作, 矩阵的转置是以对角线为轴的镜像, 这条从左上角到右下角的对角线被称为主对角线. 换句话来说, 矩阵的转置可以看成以主对角线为轴的一个镜像. 向量可以看作只有一列的矩阵。对应地, 向量的转置可以看作是只有一行的矩阵.\n标量可以看作是只有一个元素的矩阵. 因此, 标量的转置等于它本身.  We can add matrices to each other, as long as they have the same shape, just by adding their corresponding elements: $C = A + B$ where $C_{i,j} = A_{i,j} + B_ {i,j}$.\nWe can also add a scalar to a matrix or multiply a matrix by a scalar, just by performing that operation on each element of a matrix: $D = a \\cdot B + c$ where $D_{i,j} =a \\cdot B_{i,j} +c$.\nIn the context of deep learning, we also use some less conventional notation. We allow the addition of matrix and a vector, yielding another matrix: $C = A + b$, where $C_{i,j} = A_{i,j} + b_{j}$ . In other words, the vector $b$ is added to each row of the matrix. This shorthand eliminates the need to define a matrix with $b$ copied into each row before doing the addition. This implicit copying of $b$ to many locations is called broadcasting.\n 只要矩阵的形状一样, 我们可以把两个矩阵相加是指对应位置的元素相加. 标量和矩阵相乘, 或是和矩阵相加时, 我们只需将其与矩阵的每个元素相乘或相加.   深度学习中, 我们允许矩阵和向量相加. 方法是将向量和矩阵的每一行相加. 这个简写方法使我们无需在加法操作前定义一个将向量复制到每一行而生成的矩阵. 这种隐式地复制向量到很多位置的方式, 被称为广播(Broadcasting).\n Multiplying Matrices and Vectors One of the most important operations involving matrices is multiplication of two matrices. The matrix product of matrices $A$ and $B$ is a third matrix $C$. In order for this product to be defined, $A$ must have the same number of columns as $B$ has rows. If $A$ is of shape $m \\times n$ and $B$ is of shape $n \\times p$, then $C$ is of shape $m \\times p$. We can write the matrix product just by placing two or more matrices together, e.g.\n$$ C_{m \\times p} = A_{m \\times n}B_{n \\times p} \\\\ $$\nThe product operation is defined by\n$$ C_{i,j} = \\sum_{k}A_{i,k}B_{k,j} \\\\ $$\nFor example, if $A = \\begin{bmatrix} A_{1,1} \u0026 A_{1,2} \\\\ A_{2,1} \u0026 A_{2,2} \\\\ A_{3,1} \u0026 A_{3,2} \\\\ \\end{bmatrix}$ and $B = \\begin{bmatrix} B_{1,1} \u0026 B_{1,2} \\\\ B_{2,1} \u0026 B_{2,2} \\\\ \\end{bmatrix}$, then\n$$ C = A \\times B = \\begin{bmatrix} A_{1,1}B_{1,1} + A_{1,2}B_{2,1} \u0026 A_{1,1}B_{1,2} + A_{1,2}B_{2,2} \\\\ A_{2,1}B_{1,1} + A_{2,2}B_{2,1} \u0026 A_{2,1}B_{1,2} + A_{2,2}B_{2,2} \\\\ A_{3,1}B_{1,1} + A_{3,2}B_{2,1} \u0026 A_{3,1}B_{1,2} + A_{3,2}B_{2,2} \\\\ \\end{bmatrix} $$\n 两个矩阵的乘法仅当第一个矩阵 $A$ 的列数(column) 和另一个矩阵 $B$ 的行数(row) 相等时才能定义. 如 $A$ 是一个 $m \\times n$ 的矩阵, $B$ 是一个 $n \\times p$ 的矩阵，那它们的乘积 $AB$ 就会是一个 $m \\times p$ 的矩阵.\n Note that the standard product of two matrices is not just a matrix containing the product of the individual elements. Such an operation exists and is called the element-wise product or Hadamard product, and is denoted as $A \\odot B$.\nFor example,\n$$ \\begin{bmatrix} A_{1,1} \u0026 A_{1,2} \\\\ A_{2,1} \u0026 A_{2,2} \\\\ \\end{bmatrix} \\odot \\begin{bmatrix} B_{1,1} \u0026 B_{1,2} \\\\ B_{2,1} \u0026 B_{2,2} \\\\ \\end{bmatrix} = \\begin{bmatrix} A_{1,1} \\cdot B_{1,1} \u0026 A_{1,2} \\cdot B_{1,2} \\\\ A_{2,1} \\cdot B_{2,1} \u0026 A_{2,2} \\cdot B_{2,2} \\\\ \\end{bmatrix} \\\\ $$\n 两个矩阵中对应元素的乘积被称为元素对应乘积(element-wise product) 或者Hadamard乘积(Hadamard product), 记为 $A \\odot B$.\n The dot product between two vectors $x$ and $y$ of the same dimensionality is the matrix product $x^{T}y$. We can think of the matrix product $C=AB$ as computing $C_{i,j}$ as the dot product between row $i$ of $A$ and column $j$ of $B$.\nMatrix product operations have many useful properties that make mathematical analysis of matrices more convenient. For example, matrix multiplication is distributive:\n$$ A(B+C)=AB+AC \\\\ $$\nIt is also associative:\n$$ A(BC)=(AB)C \\\\ $$\n 矩阵的乘法满足结合律和对矩阵加法的分配律:\n 结合律：$A(BC)=(AB)C$  分配律：$A(B+C)=AB+AC$\n   Matrix multiplication is not commutative (the condition $AB = BA$ does not always hold), unlike scalar multiplication. However, the dot product between two vectors is commutative:\n$$ x^{T}y = y^{T}x \\\\ $$\nThe transpose of a matrix product has a simple form:\n$$ (AB)^{T} = B^{T}A^{T} \\\\ $$\n 矩阵的乘法与数乘运算之间也满足类似结合律的规律；与转置之间则满足倒置的分配律:\n $c(AB)=(cA)B=A(cB)$  $(AB)^{T} = B^{T}A^{T}$    Now, We can write down a system of linear equations:\n$$ Ax = b \\\\ $$\nWhere $A \\in R^{m \\times n}$ is a known matrix, $b \\in R^{m}$ is a known vector, and $x \\in R^{n}$ is a vector of unknown variables we would like to solve for. Each element $x_{i}$ of $x$ is one of these unknown variables. Each row of $A$ and each element of $b$ provide another constraint.\n$$ Ax = b \\Rightarrow \\begin{bmatrix} A_{1,1} \u0026 A_{1,2} \u0026 \\cdots \u0026 A_{1,n}\\\\ A_{2,1} \u0026 A_{2,2} \u0026 \\cdots \u0026 A_{2,n}\\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots\\\\ A_{m,1} \u0026 A_{m,2} \u0026 \\cdots \u0026 A_{m,n}\\\\ \\end{bmatrix} \\times \\begin{bmatrix} x_{1} \\\\ x_{2} \\\\ \\vdots \\\\ x_{n} \\\\ \\end{bmatrix} = \\begin{bmatrix} b_{1} \\\\ b_{2} \\\\ \\vdots \\\\ b_{m} \\\\ \\end{bmatrix} \\\\ $$\n$$ \\Rightarrow \\begin{cases} A_{1,1}x_{1}+A_{1,2}x_{2}+ \\cdots +A_{1,n}x_{n} = b_{1} \\\\ A_{2,1}x_{1}+A_{2,2}x_{2}+ \\cdots +A_{2,n}x_{n} = b_{2} \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\cdots \\\\ A_{m,1}x_{1}+A_{m,2}x_{2}+ \\cdots +A_{m,n}x_{n} = b_{m} \\\\ \\end{cases} $$\nIdentity and Inverse Matrices Linear algebra offers a powerful tool called matrix inversion that allows us to analytically solve equation $Ax=b$ for many values of $A$.\nTo describe matrix inversion, we first need to define the concept of an identity matrix. An identity matrix is a matrix that does not change any vector when we multiply that vector by that matrix. We denote the identity matrix that preserves $n$-dimensional vectors as $I_{n}$. Formally, $I_{n} \\in \\mathbb{R}^{n \\times n}$, and\n$$ \\forall x \\in \\mathbb{R}^{n}, I_{n}x=x \\\\ $$\nThe structure of the identity matrix is simple: all of the entries along the main diagonal are 1, while all of the other entries are zero. For example,\n$$ I_{3} = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$\n 单位矩阵(identity matrix) 的概念为, 任意向量和单位矩阵相乘, 都不会改变. 我们将保持$n$维向量不变的单位矩阵记作 $I_{n}$. 单位矩阵的结构很简单: 所有沿主对角线的元素都是1, 而所有其他位置的元素都是0.\n The matrix inverse of $A$ is denoted as $A^{-1}$, and it is defined as the matrix such that\n$$ A^{-1}A = I_{n} \\\\ $$\n 矩阵$A$的矩阵逆(matrix inversion) 记作 $A^{-1}$, 其定义的矩阵满足如下条件: $$A^{-1}A = I_{n}$$\n We can now solve equation $Ax=b$ by the following steps:\n$$ Ax=b \\Rightarrow A^{-1}Ax=A^{-1}b \\Rightarrow x = A^{-1}b \\\\ $$\nWhen $A^{-1}$ exists, several different algorithms exist for finding it in closed form. In theory, the same inverse matrix can then be used to solve the equation many times for different values of $b$ . However, $A^{-1}$ is primarily useful as a theoretical tool, and should not actually be used in practice for most software applications. Because $A^{-1}$ can be represented with only limited precision on a digital computer, algorithms that make use of the value of $b$ can usually obtain more accurate estimates of $x$.\nLinear Dependence and Span In order for $A^{-1}$ to exist, equation $Ax=b$ must have exactly one solution for every value of $b$. However, it is also possible for the system of equations to have no solutions or infinitely many solutions for some values of $b$. It is not possible to have more than one but less than infinitely many solutions for a particular $b$; if both $x$ and $y$ are solutions then\n$$ z = \\alpha x + (1-\\alpha)y \\\\ $$\nis also a solution for any real $\\alpha$.\nTo analyze how many solutions the equation has, we can think of the columns of $A$ as specifying different directions we can travel from the origin (the point specified by the vector of all zeros), and determine how many ways there are of reaching $b$. In this view, each element of $x$ specifies how far we should travel in each of these directions, with $x_{i}$ specifying how far to move in the direction of column $i$:\n$$ Ax = \\sum_{i}x_{i}A_{:,i} \\\\ $$\nIn general, this kind of operation is called a linear combination. Formally, a linear combination of some set of vectors $\\{v^{(1)}, \\cdots, v^{(n)}\\}$ is given by multiplying each vector $v^{(i)}$ by a corresponding scalar coefficient and adding the results:\n$$ \\sum_{i}c_{i}v^{(i)} \\\\ $$\nThe span of a set of vectors is the set of all points obtainable by linear combination of the original vectors.\n 一组向量的生成子空间(span) 是原始向量线性组合后所能抵达的点的集合.\n Determining whether $Ax=b$ has a solution thus amounts to testing whether $b$ is in the span of the columns of $A$. This particular span is known as the column space or the range of $A$.\nA set of vectors is linearly independent if no vector in the set is a linear combination of the other vectors. If we add a vector to a set that is a linear combination of the other vectors in the set, the new vector does not add any points to the set’s span. This means that for the column space of the matrix to encompass all of $\\mathbb{R}^{m}$, the matrix must contain at least one set of $m$ linearly independent columns. This condition is both necessary and sufficient for equation $Ax=b$ to have a solution for every value of $b$. Note that the requirement is for a set to have exactly $m$ linear independent columns, not at least $m$. No set of $m$-dimensional vectors can have more than m mutually linearly independent columns, but a matrix with more than $m$ columns may have more than one such set.\n 如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为线性无关 (linearly independent) .\n In order for the matrix to have an inverse, we additionally need to ensure that equation $Ax=b$ has at most one solution for each value of $b$. To do so, we need to ensure that the matrix has at most $m$ columns. Otherwise there is more than one way of parametrizing each solution.\nTogether, this means that the matrix must be square, that is, we require that $m=n$ and that all of the columns must be linearly independent. A square matrix with linearly dependent columns is known as singular.\nIf $A$ is not square or is square but singular, it can still be possible to solve the equation. However, we can not use the method of matrix inversion to find the solution.\nNorms Sometimes we need to measure the size of a vector. In machine learning, we usually measure the size of vectors using a function called a norm. Formally, the $L^{p}$ norm is given by\n$$ \\lVert x \\rVert_{p} = \\left(\\sum_{i}|x_{i}|^{p}\\right)^{\\frac{1}{p}} \\\\ $$\nfor $p \\in \\mathbb{R}$, $p1$.\n 我们经常使用被称为范数 (norm) 的函数衡量向量大小. 范数是将向量映射到非负值的函数. 直观上来说, 向量 $x$ 的范数衡量从原点到点 $x$ 的距离.\n Norms, including the $L^{p}$ norm, are functions mapping vectors to non-negative values. On an intuitive level, the norm of a vector $x$ measures the distance from the origin to the point $x$. More rigorously, a norm is any function $f$ that satisfies the following properties:\n $f(x) = 0 \\Rightarrow x = 0$ $f(x+y) \\leq f(x) + f(y)$ (the triangle inequality) $\\forall \\alpha \\in \\mathbb{R}, f(\\alpha x) = |\\alpha|f(x)$   范数 (norm) 满足以下性质：\n $f(x) = 0 \\Rightarrow x = 0$  $f(x+y) \\leq f(x) + f(y)$ (满足三角不等式, 或称次可加性)\n $\\forall \\alpha \\in \\mathbb{R}, f(\\alpha x) = |\\alpha|f(x)$ (具有绝对一次齐次性)\n   The $L^{2}$ norm, with $p=2$, is known as the Euclidean norm. It is simply the Euclidean distance from the origin to the point identified by $x$. The $L^{2}$ norm is used so frequently in machine learning that it is often denoted simply as $\\lVert x \\rVert$, with the subscript 2 omitted. It is also common to measure the size of a vector using the squared $L^{2}$ norm, which can be calculated simply as $x^{T}x$.\n$$ \\lVert x \\rVert_{2} = \\sqrt{\\sum_{i}|x_{i}|^{2}} \\\\ $$\n 当 $p=2$ 时，$L^{2}$ 范数被称为欧几里得范数(Euclidean norm) .它表示从原点出发到向量 $x$ 确定的点的欧几里得距离.\n The $L^{1}$ norm is commonly used in machine learning when the difference between zero and nonzero elements is very important. Every time an element of $x$ moves away from 0 by $\\varepsilon$, the $L^{1}$ norm increases by $\\varepsilon$. The $L^{1}$ norm may be simplified to\n$$ \\lVert x \\rVert_{1} = \\sum_{i}|x_{i}| \\\\ $$\nOne other norm that commonly arises in machine learning is the $L^{\\infty}$ norm, also known as the max norm. This norm simplifies to the absolute value of the element with the largest magnitude in the vector,\n$$ \\lVert x \\rVert_{\\infty} = max_{i}|x_{i}| \\\\ $$\nSometimes we may also wish to measure the size of a matrix. In the context of deep learning, the most common way to do this is with the otherwise obscure Frobenius norm:\n$$ \\lVert x \\rVert_{F} = \\sqrt{\\sum_{i,j}A_{i,j}^{2}} \\\\ $$\nThe dot product of two vectors can be rewritten in terms of norms. Specifically,\n$$ x^{T}y = \\lVert x \\rVert_{2}\\lVert y \\rVert_{2} \\cos{\\theta} \\\\ $$\nwhere $\\theta$ is the angle between $x$ and $y$.\nSpecial Kinds of Matrices and Vectors Some special kinds of matrices and vectors are particularly useful.\nDiagonal matrices consist mostly of zeros and have non-zero entries only along the main diagonal. Formally, a matrix $D$ is diagonal if and only if $D_{i,j}=0$ for all $i \\neq j$. We have already seen one example of a diagonal matrix: the identity matrix, where all of the diagonal entries are 1. We write $diag(v)$ to denote a square diagonal matrix whose diagonal entries are given by the entries of the vector $v$, e.g.,\n$$ v = \\begin{bmatrix} a_{1} \\\\ a_{2} \\\\ a_{3} \\\\ \\end{bmatrix} \\Rightarrow diag(v) = \\begin{bmatrix} a_{1} \u0026 0 \u0026 0 \\\\ 0 \u0026 a_{2} \u0026 0 \\\\ 0 \u0026 0 \u0026 a_{3} \\\\ \\end{bmatrix} $$\nDiagonal matrices are of interest in part because multiplying by a diagonal matrix is very computationally efficient. To compute $diag(v)x$, we only need to scale each element $x_{i}$ by $v_{i}$. In other words, $diag(v)x = v \\odot x$. Inverting a square diagonal matrix is also efficient. The inverse exists only if every diagonal entry is nonzero, $diag(v)^{-1}= diag([\\frac{1}{v_{1}}, \\cdots, \\frac{1}{v_{n}}]^{T})$.\n 对角矩阵(diagonal matrix) 只在主对角线上含有非零元素, 其他位置都是零.\n A symmetric matrix is any matrix that is equal to its own transpose:\n$$ A = A^{T} \\\\ $$\nFor example,\n$$ A = A^{T} = \\begin{bmatrix} 1 \u0026 2 \\\\ 2 \u0026 3 \\\\ \\end{bmatrix} \\ \\ \\ \\ \\ \\ \\ \\ B = B^{T} = \\begin{bmatrix} 5 \u0026 6 \u0026 7 \\\\ 6 \u0026 3 \u0026 2 \\\\ 7 \u0026 2 \u0026 1 \\\\ \\end{bmatrix} $$\nSymmetric matrices often arise when the entries are generated by some function of two arguments that does not depend on the order of the arguments. For example, if $A$ is a matrix of distance measurements, with $A_{i,j}$ giving the distance from point $i$ to point $j$, then $A_{i,j} = A_{j,i}$ because distance functions are symmetric.\n 对称矩阵(symmetric matrix) 是转置和自己相等的矩阵.\n A unit vector is a vector with unit norm:\n$$ \\lVert x \\rVert_{2} = 1 \\\\ $$\nA vector $x$ and a vector $y$ are orthogonal to each other if $x^{T}y=0$. If both vectors have nonzero norm, this means that they are at a 90 degree angle to each other. In $\\mathbb{R}^{n}$, at most $n$ vectors may be mutually orthogonal with nonzero norm. If the vectors are not only orthogonal but also have unit norm, we call them orthonormal.\n 单位向量(unit vector) 是具有单位范数(unit norm) 的向量. 如果 $x^{T}y=0$，那么向量 $x$ 和向量 $y$ 互相正交(orthogonal) . 如果两个向量都有非零范数, 那么这两个向量之间的夹角是90度. 如果这些向量不仅互相正交，并且范数都为 1，那么我们称它们是标准正交(orthonormal) .\n An orthogonal matrix is a square matrix whose rows are mutually orthonormal and whose columns are mutually orthonormal:\n$$ A^{T}A = AA^{T} = I \\\\ $$\nThis implies that\n$$ A^{-1} = A^{T} \\\\ $$\nso orthogonal matrices are of interest because their inverse is very cheap to compute. Pay careful attention to the definition of orthogonal matrices. Counterintuitively, their rows are not merely orthogonal but fully orthonormal. There is no special term for a matrix whose rows or columns are orthogonal but not orthonormal.\nEigendecomposition Much as we can discover something about the true nature of an integer by decomposing it into prime factors, we can also decompose matrices in ways that show us information about their functional properties that is not obvious from the representation of the matrix as an array of elements.\nOne of the most widely used kinds of matrix decomposition is called eigendecomposi-tion, in which we decompose a matrix into a set of eigenvectors and eigenvalues.\nAn eigenvector of a square matrix $A$ is a non-zero vector $v$ such that multiplication by $A$ alters only the scale of $v$:\n$$ Av = \\lambda v \\\\ $$\nThe scalar $\\lambda$ is known as the eigenvalue corresponding to this eigenvector. If $v$ is an eigenvector of $A$, then so is any rescaled vector $sv$ for $s \\in \\mathbb{R}$, $s \\neq 0$. Moreover, $sv$ still has the same eigenvalue. For this reason, we usually only look for unit eigenvectors.\n 特征分解(eigendecomposition) 是使用最广的矩阵分解之一, 即我们将矩阵分解成一组特征向量和特征值. 方阵 $A$ 的特征向量(eigenvector) 是指与 $A$ 相乘后相当于对该向量进行缩放的非零向量 $v$: $$Av = \\lambda v \\\\$$ 标量 $\\lambda$ 被称为这个特征向量对应的特征值(eigenvalue) .\n Suppose that a matrix $A$ has $n$ linearly independent eigenvectors, $\\{v^{(1)}, \\cdots, v^{(n)}\\}$, with corresponding eigenvalues $\\{\\lambda_{1}, \\cdots, \\lambda_{n}\\}$. We may concatenate all of the eigenvectors to form a matrix $V$ with one eigenvector per column: $V=[v^{(1)}, \\cdots, v^{(n)}]$. Likewise, we can concatenate the eigenvalues to form a vector $\\lambda = [\\lambda_{1}, \\cdots, \\lambda_{n}]^{T}$. The eigendecomposi-tion of $A$ is then given by\n$$ A = V diag(\\lambda)V^{-1} \\\\ $$\n $A$的特征分解(eigendecomposition) 可以记作: $$A = V diag(\\lambda)V^{-1} $$\n We have seen that constructing matrices with specific eigenvalues and eigenvectors allows us to stretch space in desired directions. However, we often want to decompose matrices into their eigenvalues and eigenvectors. Doing so can help us to analyze certain properties of the matrix, much as decomposing an integer into its prime factors can help us understand the behavior of that integer. Not every matrix can be decomposed into eigenvalues and eigenvectors. In some cases, the decomposition exists, but may involve complex rather than real numbers.\nSingular Value Decomposition We already known how to decompose a matrix into eigenvectors and eigenvalues. The singular value decomposition (SVD) provides another way to factorize a matrix, into singular vectors and singular values. The SVD allows us to discover some of the same kind of information as the eigendecomposition. However, the SVD is more generally applicable. Every real matrix has a singular value decomposition, but the same is not true of the eigenvalue decomposition. For example, if a matrix is not square, the eigendecom-position is not defined, and we must use a singular value decomposition instead.\nRecall that the eigendecomposition involves analyzing a matrix $A$ to discover a matrix $V$ of eigenvectors and a vector of eigenvalues $\\lambda$ such that we can rewrite $A$ as\n$$ A = V diag(\\lambda)V^{-1} \\\\ $$\nThe singular value decomposition is similar, except this time we will write $A$ as a product of three matrices:\n$$ A = UDV^{T} \\\\ $$\nSuppose that $A$ is an $m \\times n$ matrix. Then $U$ is defined to be an $m \\times m$ matrix, $D$ to be an $m \\times n$ matrix, and $V$ to be an $n \\times n$ matrix.\n 奇异值分解(singular value decomposition, SVD), 将矩阵分解为奇异向量(singular vector) 和奇异值(singular value) : $$A = UDV^{T} \\\\$$ 如果 $A$ 是一个 $m \\times n$ 的矩阵. 那么 $U$ 是一个 $m \\times m$ 的矩阵, $D$ 是一个 $m \\times n$ 的矩阵, $V$ 是一个 $n \\times n$ 的矩阵.\n Each of these matrices is defined to have a special structure. The matrices $U$ and $V$ are both defined to be orthogonal matrices. The matrix $D$ is defined to be a diagonal matrix. Note that $D$ is not necessarily square.\nThe elements along the diagonal of $D$ are known as the singular values of the matrix $A$. The columns of $U$ are known as the left-singular vectors. The columns of $V$ are known as as the right-singular vectors.\nThe Trace Operator The trace operator gives the sum of all of the diagonal entries of a matrix:\n$$ Tr(A) = \\sum_{i}A_{i,i} \\\\ $$\n 迹运算(trace operator) 返回的是矩阵对角元素的和.\n For example, let $A$ be a matrix, with\n$$ A = \\begin{bmatrix} a_{1,1} \u0026 a_{1,2} \\\\ a_{2,1} \u0026 a_{2,2} \\\\ \\end{bmatrix} $$\nThen,\n$$ Tr(A) = \\sum_{i=1}^{2}a_{i,i} = a_{1,1} + a_{2,2} $$\nThe trace operator is useful for a variety of reasons. Some operations that are difficult to specify without resorting to summation notation can be specified using matrix products and the trace operator. For example, the trace operator provides an alternative way of writing the Frobenius norm of a matrix:\n$$ \\lVert x \\rVert_{F} = \\sqrt{Tr(AA^{T})} \\\\ $$\nWriting an expression in terms of the trace operator opens up opportunities to manipulate the expression using many useful identities. For example, the trace operator is invariant to the transpose operator:\n$$ Tr(A) = Tr(A^{T}) \\\\ $$\nThe trace of a square matrix composed of many factors is also invariant to moving the last factor into the first position, if the shapes of the corresponding matrices allow the resulting product to be defined:\n$$ Tr(ABC) = Tr(CAB) = Tr(BCA) \\\\ $$\nThis invariance to cyclic permutation holds even if the resulting product has a different shape. For example, for $A \\in \\mathbb{R}^{m \\times n}$ and $B \\in \\mathbb{R}^{n \\times m}$, we have\n$$ Tr(AB) = Tr(BA) \\\\ $$\neven though $AB \\in \\mathbb{R}^{m \\times m}$ and $BA \\in \\mathbb{R}^{n \\times n}$\nAnother useful fact to keep in mind is that a scalar is its own trace: $a = Tr(a)$.\nThe Determinant The determinant of a square matrix, denoted $det(A)$, is a function mapping matrices to real scalars. The determinant is equal to the product of all the eigenvalues of the matrix. The absolute value of the determinant can be thought of as a measure of how much multiplication by the matrix expands or contracts space. If the determinant is 0, then space is contracted completely along at least one dimension, causing it to lose all of its volume. If the determinant is 1, then the transformation preserves volume.\n 行列式(determinant) 是一个将方阵映射到实数的函数. 行列式等于矩阵特征值的乘积.\n For example, for a $2 \\times 2$ matrix:\n$$ A = \\begin{bmatrix} a \u0026 b \\\\ c \u0026 d \\\\ \\end{bmatrix} $$\nThe determinant is:\n$$ det(A) = |A| = ad - bc $$\nJacobian and Hessian Matrices Sometimes we need to find all of the partial derivatives of a function whose input and output are both vectors. The matrix containing all such partial derivatives is known as a Jacobian matrix. Specifically, if we have a function $f: \\mathbb{R}^{m} \\to \\mathbb{R}^{n}$, then the Jacobian matrix $J \\in \\mathbb{R}^{n \\times m}$ of $f$ is defined such that $J_{i,j}=\\frac{\\partial}{\\partial x_{j}}f(x)_{i}$.\n$$ J = \\begin{bmatrix} \\frac{\\partial f}{\\partial x_{1}} \u0026 \\cdots \u0026 \\frac{\\partial f}{\\partial x_{n}} \\\\ \\end{bmatrix} = \\begin{bmatrix} \\nabla^{T}f_{1} \\\\ \\vdots \\\\ \\nabla^{T}f_{m} \\\\ \\end{bmatrix} = \\begin{bmatrix} \\frac{\\partial f_{1}}{\\partial x_{1}} \u0026 \\cdots \u0026 \\frac{\\partial f_{1}}{\\partial x_{n}} \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\frac{\\partial f_{m}}{\\partial x_{1}} \u0026 \\cdots \u0026 \\frac{\\partial f_{m}}{\\partial x_{n}} \\\\ \\end{bmatrix} \\\\ $$\n 有时我们需要计算输入和输出都为向量的函数的所有偏导数.包含所有这样的偏导数的矩阵被称为 Jacobian 矩阵.\n We are also sometimes interested in a derivative of a derivative. This is known as a second derivative. For example, for a function $f: \\mathbb{R}^{n} \\to \\mathbb{R}$, the derivative with respect to $x_{i}$ of the derivative of $f$ with respect to $x_{j}$ is denoted as $\\frac{\\partial^{2}}{\\partial x_{i}\\partial x_{j}}f$. In a single dimension, we can denote $\\frac{d^{2}}{dx^{2}}f$ by $f''(x)$. The second derivative tells us how the first derivative will change as we vary the input. This is important because it tells us whether a gradient step will cause as much of an improvement as we would expect based on the gradient alone. We can think of the second derivative as measuring curvature.\nWhen our function has multiple input dimensions, there are many second derivatives. These derivatives can be collected together into a matrix called the Hessian matrix. The Hessian matrix $H(f)(x)$ is defined such that $H(f)(x)_{i,j} = \\frac{\\partial^{2}}{\\partial x_{i}\\partial x_{j}}f(x)$\n$$ H(f)(x)_{i,j} = \\begin{bmatrix} \\frac{\\partial^{2} f}{\\partial x_{1}^{2}} \u0026 \\frac{\\partial^{2} f}{\\partial x_{1}\\partial x_{2}} \u0026 \\cdots \u0026 \\frac{\\partial^{2} f}{\\partial x_{1}\\partial x_{n}} \\\\ \\frac{\\partial^{2} f}{\\partial x_{2}\\partial x_{1}} \u0026 \\frac{\\partial^{2} f}{\\partial x_{2}^{2}} \u0026 \\cdots \u0026 \\frac{\\partial^{2} f}{\\partial x_{2}\\partial x_{n}} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\frac{\\partial^{2} f}{\\partial x_{n}\\partial x_{1}} \u0026 \\frac{\\partial^{2} f}{\\partial x_{n}\\partial x_{2}} \u0026 \\cdots \u0026 \\frac{\\partial^{2} f}{\\partial x_{n}^{2}} \\\\ \\end{bmatrix} \\\\ $$\nEquivalently, the Hessian is the Jacobian of the gradient.\n 当我们的函数具有多维输入时,二阶导数也有很多.我们可以将这些导数合并成一个矩阵,称为 Hessian 矩阵.\n Anywhere that the second partial derivatives are continuous, the differential operators are commutative, i.e. their order can be swapped:\n$$ \\frac{\\partial^{2}}{\\partial x_{i}\\partial x_{j}}f(x)=\\frac{\\partial^{2}}{\\partial x_{j}\\partial x_{i}}f(x) \\\\ $$\nThis implies that $H_{i,j}=h_{j,i}$, so the Hessian matrix is symmetric at such points. Most of the functions we encounter in the context of deep learning have a symmetric Hessian almost everywhere. Because the Hessian matrix is real and symmetric, we can decompose it into a set of real eigenvalues and an orthogonal basis of eigenvectors. The second derivative in a specific direction represented by a unit vector $f$ is given by $d^{T}Hd$. When $d$ is an eigenvector of $H$ , the second derivative in that direction is given by the corresponding eigenvalue. For other directions of $d$, the directional second derivative is a weighted average of all of the eigenvalues, with weights between 0 and 1, and eigenvectors that have smaller angle with $d$ receiving more weight. The maximum eigenvalue determines the maximum second derivative and the minimum eigenvalue determines the minimum second derivative.\nReference [1] Goodfellow, I., Bengio, Y., \u0026 Courville, A. (2016, Nov 18). Deep Learning. https://www.deeplearningbook.org/contents/linear_algebra.html.\n",
  "wordCount" : "4748",
  "inLanguage": "en",
  "datePublished": "2021-06-23T00:00:00Z",
  "dateModified": "2021-06-23T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Followb1ind1y"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://followb1ind1y.github.io/posts/applied_math_and_ml_basics/01_linear_algebra_for_ml/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Followb1ind1y",
    "logo": {
      "@type": "ImageObject",
      "url": "https://followb1ind1y.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://followb1ind1y.github.io/" accesskey="h" title="Followb1ind1y (Alt + H)">Followb1ind1y</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://followb1ind1y.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://followb1ind1y.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://followb1ind1y.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://followb1ind1y.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://followb1ind1y.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://followb1ind1y.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      [ML Basics] Linear Algebra
    </h1>
    <div class="post-meta">June 23, 2021&nbsp;·&nbsp;23 min&nbsp;·&nbsp;Followb1ind1y
</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <div class="details">Table of Contents</div>
        </summary>
        <div class="inner"><ul>
                <li>
                    <a href="#scalars-vectors-matrices-and-tensors" aria-label="Scalars, Vectors, Matrices and Tensors">Scalars, Vectors, Matrices and Tensors</a></li>
                <li>
                    <a href="#multiplying-matrices-and-vectors" aria-label="Multiplying Matrices and Vectors">Multiplying Matrices and Vectors</a></li>
                <li>
                    <a href="#identity-and-inverse-matrices" aria-label="Identity and Inverse Matrices">Identity and Inverse Matrices</a></li>
                <li>
                    <a href="#linear-dependence-and-span" aria-label="Linear Dependence and Span">Linear Dependence and Span</a></li>
                <li>
                    <a href="#norms" aria-label="Norms">Norms</a></li>
                <li>
                    <a href="#special-kinds-of-matrices-and-vectors" aria-label="Special Kinds of Matrices and Vectors">Special Kinds of Matrices and Vectors</a></li>
                <li>
                    <a href="#eigendecomposition" aria-label="Eigendecomposition">Eigendecomposition</a></li>
                <li>
                    <a href="#singular-value-decomposition" aria-label="Singular Value Decomposition">Singular Value Decomposition</a></li>
                <li>
                    <a href="#the-trace-operator" aria-label="The Trace Operator">The Trace Operator</a></li>
                <li>
                    <a href="#the-determinant" aria-label="The Determinant">The Determinant</a></li>
                <li>
                    <a href="#jacobian-and-hessian-matrices" aria-label="Jacobian and Hessian Matrices">Jacobian and Hessian Matrices</a></li>
                <li>
                    <a href="#reference" aria-label="Reference">Reference</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="scalars-vectors-matrices-and-tensors">Scalars, Vectors, Matrices and Tensors<a hidden class="anchor" aria-hidden="true" href="#scalars-vectors-matrices-and-tensors">#</a></h2>
<p>The study of linear algebra involves several types of mathematical objects:</p>
<ul>
<li>
<p><strong>Scalars</strong>: A scalar is just a single number, in contrast to most of the other objects studied in linear algebra, which are usually arrays of multiple numbers. We write scalars in italics. We usually give scalars lowercase variable names. When we introduce them, we specify what kind of number they are. For example, we might say &ldquo;Let <code>$s \in \mathbb{R}$</code> be the slope of the line,&rdquo; while defining a real-valued scalar, or &ldquo;Let <code>$n \in \mathbb{N}$</code> be the number of units, while defining an natural number scalar.</p>
</li>
<li>
<p><strong>Vectors</strong>: A vector is an array of numbers. The numbers are arranged in order. We can identify each individual number by its index in that ordering. Typically we give vectors lowercase names in bold typeface, such as <code>$\mathbf{x}$</code>. The elements of the vector are identified by writing its name in italic typeface, with a subscript. We also need to say what kind of numbers are stored in the vector. If each element is in <code>$\mathbb{R}$</code>, and the vector has <code>$n$</code> elements, then the vector lies in the set formed by taking the Cartesian product of <code>$\mathbb{R}$</code> <code>$n$</code> times, denoted as <code>$\mathbb{R}^{n}$</code>. When we need to explicitly identify the elements of a vector, we write them as a column enclosed in square brackets:</p>
</li>
</ul>
<p><code>$$ \begin{bmatrix} x_{1} \\ x_{2} \\ \vdots \\ x_{n} \\ \end{bmatrix} $$</code></p>
<ul>
<li><strong>Matrices</strong>: A matrix is a 2-D array of numbers, so each element is identified by two indices instead of just one. We usually give matrices upper-case variable names with bold typeface, such as <code>$\mathbf{A}$</code>. If a real-valued matrix <code>$\mathbf{A}$</code> has a height of <code>$m$</code> and a width of <code>$n$</code>, then we say that <code>$\mathbf{A} \in \mathbb{R}^{m \times  n}$</code>. We usually identify the elements of a matrix using its name in italic but not bold font, and the indices are listed with separating commas. For example, <code>$A_{1,1}$</code> is the upper left entry of <code>$\mathbf{A}$</code> and <code>$A_{m,n}$</code> is the bottom right entry. We can identify all of the numbers with vertical coordinate <code>$i$</code> by writing a &ldquo;:&rdquo; for the horizontal coordinate. For example, <code>$A_{i,:}$</code> denotes the horizontal cross section of <code>$\mathbf{A}$</code> with vertical coordinate <code>$i$</code>. This is known as the <code>$i$</code>-th <strong>row</strong> of <code>$\mathbf{A}$</code>. Likewise, <code>$A_{:,i}$</code> is the <code>$i$</code>-th <strong>column</strong> of <code>$\mathbf{A}$</code>. When we need to explicitly identify the elements of a matrix, we write them as an array enclosed in square brackets:</li>
</ul>
<p><code>$$ \begin{bmatrix} A_{1,1} &amp; A_{1,2} \\ A_{2,1} &amp; A_{2,2} \\ \end{bmatrix} $$</code></p>
<ul>
<li><strong>Tensors</strong>: In some cases we will need an array with more than two axes. In the general case, an array of numbers arranged on a regular grid with a variable number of axes is known as a tensor. We denote a tensor named &ldquo;A&rdquo; with this typeface: <code>$\mathsf{A}$</code>. We identify the element of <code>$\mathsf{A}$</code> at coordinates <code>$(i,j,k)$</code> by writing <code>$A_{i,j,k}$</code>.</li>
</ul>
<blockquote>
<p><strong>标量(Scalar)</strong>: 标量是一个单独的数. <br>
<strong>向量(Vector)</strong>: 向量是一列有序排列的数. <br>
<strong>矩阵(Matrix)</strong>: 矩阵是一个二维数组, 其中的每一个元素被两个索引. <br>
<strong>张量(Tensor)</strong>: 张量是一个超过二维的数组. <br></p>
</blockquote>
<p>One important operation on matrices is the <strong>transpose</strong>. The transpose of a matrix is the mirror image of the matrix across a diagonal line, called the <strong>main diagonal</strong>, running down and to the right, starting from its upper left corner. We denote the transpose of a matrix <code>$A$</code> as <code>$A^{T}$</code>, and it is defined such that</p>
<p><code>$$ (A^{T})_{i,j} = A_{j,i} $$</code></p>
<div align="center">
  <img src="/img_ML_Basics/ML_Basics_01_Transpose.PNG" width=500px/>
</div>
<br>
<p>Vectors can be thought of as matrices that contain only one column. The transpose of a vector is therefore a matrix with only one row. Sometimes we define a vector by writing out its elements in the text inline as a row matrix, then using the transpose operator to turn it into a standard column vector, e.g., <code>$x = \begin{bmatrix} x_{1}, x_{2}, x_{3} \\ \end{bmatrix}^{T}$</code>.</p>
<p>A scalar can be thought of as a matrix with only a single entry. From this, we can see that a scalar is its own transpose: <code>$a = a^{T}$</code>.</p>
<blockquote>
<p><strong>转置(Transpose)</strong> 是矩阵的一种重要操作, 矩阵的转置是以对角线为轴的镜像, 这条从左上角到右下角的对角线被称为<strong>主对角线</strong>. 换句话来说, 矩阵的转置可以看成以主对角线为轴的一个镜像. <br>
<strong>向量</strong>可以看作只有一列的矩阵。对应地, 向量的转置可以看作是只有一行的矩阵.<br>
<strong>标量</strong>可以看作是只有一个元素的矩阵. 因此, 标量的转置等于它本身. <br></p>
</blockquote>
<p>We can add matrices to each other, as long as they have the same shape, just by adding their corresponding elements: <code>$C = A + B$</code> where <code>$C_{i,j} = A_{i,j} + B_ {i,j}$</code>.</p>
<p>We can also add a scalar to a matrix or multiply a matrix by a scalar, just by performing that operation on each element of a matrix: <code>$D = a \cdot B + c$</code> where <code>$D_{i,j} =a \cdot B_{i,j} +c$</code>.</p>
<p>In the context of deep learning, we also use some less conventional notation. We allow the addition of matrix and a vector, yielding another matrix: <code>$C = A + b$</code>, where <code>$C_{i,j} = A_{i,j} + b_{j}$</code> . In other words, the vector <code>$b$</code> is added to each row of the matrix. This shorthand eliminates the need to define a matrix with <code>$b$</code> copied into each row before doing the addition. This implicit copying of <code>$b$</code> to many locations is called <strong>broadcasting</strong>.</p>
<blockquote>
<p>只要矩阵的<strong>形状一样</strong>, 我们可以把<strong>两个矩阵</strong>相加是指对应位置的元素相加. <br>
<strong>标量和矩阵</strong>相乘, 或是和矩阵相加时, 我们只需将其与矩阵的每个元素相乘或相加. <br></p>
</blockquote>
<blockquote>
<p>深度学习中, 我们允许<strong>矩阵和向量相加</strong>. 方法是将向量和矩阵的每一行相加. 这个简写方法使我们无需在加法操作前定义一个将向量复制到每一行而生成的矩阵. 这种隐式地复制向量到很多位置的方式, 被称为<strong>广播(Broadcasting)</strong>.</p>
</blockquote>
<h2 id="multiplying-matrices-and-vectors">Multiplying Matrices and Vectors<a hidden class="anchor" aria-hidden="true" href="#multiplying-matrices-and-vectors">#</a></h2>
<p>One of the most important operations involving matrices is multiplication of two matrices. The <strong>matrix product</strong> of matrices <code>$A$</code> and <code>$B$</code> is a third matrix <code>$C$</code>. In order for this product to be defined, <code>$A$</code> must have the same number of columns as <code>$B$</code> has rows. If <code>$A$</code> is of shape <code>$m \times n$</code> and <code>$B$</code> is of shape <code>$n \times p$</code>, then <code>$C$</code> is of shape <code>$m \times p$</code>. We can write the matrix product just by placing two or more matrices together, e.g.</p>
<p><code>$$ C_{m \times p} = A_{m \times n}B_{n \times p} \\ $$</code></p>
<p>The product operation is defined by</p>
<p><code>$$ C_{i,j} = \sum_{k}A_{i,k}B_{k,j} \\ $$</code></p>
<p>For example, if <code>$A = \begin{bmatrix} A_{1,1} &amp; A_{1,2} \\ A_{2,1} &amp; A_{2,2} \\ A_{3,1} &amp; A_{3,2} \\ \end{bmatrix}$</code> and <code>$B = \begin{bmatrix} B_{1,1} &amp; B_{1,2} \\ B_{2,1} &amp; B_{2,2} \\ \end{bmatrix}$</code>, then</p>
<p><code>$$ C = A \times B = \begin{bmatrix} A_{1,1}B_{1,1} + A_{1,2}B_{2,1} &amp; A_{1,1}B_{1,2} + A_{1,2}B_{2,2} \\ A_{2,1}B_{1,1} + A_{2,2}B_{2,1} &amp; A_{2,1}B_{1,2} + A_{2,2}B_{2,2} \\ A_{3,1}B_{1,1} + A_{3,2}B_{2,1} &amp; A_{3,1}B_{1,2} + A_{3,2}B_{2,2} \\ \end{bmatrix} $$</code></p>
<blockquote>
<p>两个<strong>矩阵的乘法</strong>仅当第一个矩阵 <code>$A$</code> 的<strong>列数(column)</strong> 和另一个矩阵 <code>$B$</code> 的<strong>行数(row)</strong> 相等时才能定义. 如 <code>$A$</code> 是一个 <code>$m \times n$</code> 的矩阵, <code>$B$</code> 是一个 <code>$n \times p$</code> 的矩阵，那它们的乘积 <code>$AB$</code> 就会是一个 <code>$m \times p$</code> 的矩阵.</p>
</blockquote>
<p>Note that the standard product of two matrices is not just a matrix containing the product of the individual elements. Such an operation exists and is called the <strong>element-wise</strong> product or <strong>Hadamard product</strong>, and is denoted as <code>$A \odot B$</code>.</p>
<p>For example,</p>
<p><code>$$ \begin{bmatrix} A_{1,1} &amp; A_{1,2} \\ A_{2,1} &amp; A_{2,2} \\ \end{bmatrix} \odot \begin{bmatrix} B_{1,1} &amp; B_{1,2} \\ B_{2,1} &amp; B_{2,2} \\ \end{bmatrix} = \begin{bmatrix} A_{1,1} \cdot B_{1,1} &amp; A_{1,2} \cdot B_{1,2} \\ A_{2,1} \cdot B_{2,1} &amp; A_{2,2} \cdot B_{2,2} \\ \end{bmatrix} \\ $$</code></p>
<blockquote>
<p>两个矩阵中对应元素的乘积被称为<strong>元素对应乘积(element-wise product)</strong> 或者<strong>Hadamard乘积(Hadamard product)</strong>, 记为 <code>$A \odot B$</code>.</p>
</blockquote>
<p>The <strong>dot product</strong> between two vectors <code>$x$</code> and <code>$y$</code> of the same dimensionality is the matrix product <code>$x^{T}y$</code>. We can think of the matrix product <code>$C=AB$</code> as computing <code>$C_{i,j}$</code> as the dot product between row <code>$i$</code> of <code>$A$</code> and column <code>$j$</code> of <code>$B$</code>.</p>
<p>Matrix product operations have many useful properties that make mathematical analysis of matrices more convenient. For example, matrix multiplication is distributive:</p>
<p><code>$$ A(B+C)=AB+AC \\ $$</code></p>
<p>It is also associative:</p>
<p><code>$$ A(BC)=(AB)C \\ $$</code></p>
<blockquote>
<p>矩阵的乘法满足结合律和对矩阵加法的分配律:</p>
<ul>
<li><strong>结合律</strong>：<code>$A(BC)=(AB)C$</code> <br></li>
<li><strong>分配律</strong>：<code>$A(B+C)=AB+AC$</code><br></li>
</ul>
</blockquote>
<p>Matrix multiplication is <strong>not</strong> commutative (the condition <code>$AB = BA$</code> does <strong>not</strong> always hold), unlike scalar multiplication. However, the dot product between two vectors is commutative:</p>
<p><code>$$ x^{T}y = y^{T}x \\ $$</code></p>
<p>The transpose of a matrix product has a simple form:</p>
<p><code>$$ (AB)^{T} = B^{T}A^{T} \\ $$</code></p>
<blockquote>
<p>矩阵的乘法与数乘运算之间也满足类似结合律的规律；与转置之间则满足倒置的分配律:</p>
<ul>
<li><code>$c(AB)=(cA)B=A(cB)$</code> <br></li>
<li><code>$(AB)^{T} = B^{T}A^{T}$</code> <br></li>
</ul>
</blockquote>
<p>Now, We can write down a <strong>system of linear equations</strong>:</p>
<p><code>$$ Ax = b \\ $$</code></p>
<p>Where <code>$A \in R^{m \times n}$</code> is a known matrix, <code>$b \in R^{m}$</code> is a known vector, and <code>$x \in R^{n}$</code> is a vector of unknown variables we would like to solve for. Each element <code>$x_{i}$</code> of <code>$x$</code> is one of these unknown variables. Each row of <code>$A$</code> and each element of <code>$b$</code> provide another constraint.</p>
<p><code>$$ Ax = b \Rightarrow \begin{bmatrix} A_{1,1} &amp; A_{1,2} &amp; \cdots &amp; A_{1,n}\\ A_{2,1} &amp; A_{2,2} &amp; \cdots &amp; A_{2,n}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\ A_{m,1} &amp; A_{m,2} &amp; \cdots &amp; A_{m,n}\\ \end{bmatrix} \times \begin{bmatrix} x_{1} \\ x_{2} \\ \vdots \\ x_{n} \\ \end{bmatrix} = \begin{bmatrix} b_{1} \\ b_{2} \\ \vdots \\ b_{m} \\ \end{bmatrix} \\ $$</code></p>
<p><code>$$ \Rightarrow \begin{cases} A_{1,1}x_{1}+A_{1,2}x_{2}+ \cdots +A_{1,n}x_{n} = b_{1} \\ A_{2,1}x_{1}+A_{2,2}x_{2}+ \cdots +A_{2,n}x_{n} = b_{2} \\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \cdots \\ A_{m,1}x_{1}+A_{m,2}x_{2}+ \cdots +A_{m,n}x_{n} = b_{m} \\ \end{cases} $$</code></p>
<h2 id="identity-and-inverse-matrices">Identity and Inverse Matrices<a hidden class="anchor" aria-hidden="true" href="#identity-and-inverse-matrices">#</a></h2>
<p>Linear algebra offers a powerful tool called <strong>matrix inversion</strong> that allows us to
analytically solve equation <code>$Ax=b$</code> for many values of <code>$A$</code>.</p>
<p>To describe matrix inversion, we first need to define the concept of an <strong>identity matrix</strong>. An identity matrix is a matrix that does not change any vector when we multiply that vector by that matrix. We denote the identity matrix that preserves <code>$n$</code>-dimensional vectors as <code>$I_{n}$</code>. Formally, <code>$I_{n} \in \mathbb{R}^{n \times n}$</code>, and</p>
<p><code>$$ \forall x \in \mathbb{R}^{n}, I_{n}x=x \\ $$</code></p>
<p>The structure of the identity matrix is simple: all of the entries along the main diagonal are 1, while all of the other entries are zero. For example,</p>
<p><code>$$ I_{3} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \\ \end{bmatrix} $$</code></p>
<blockquote>
<p><strong>单位矩阵(identity matrix)</strong> 的概念为, 任意向量和单位矩阵相乘, 都不会改变. 我们将保持<code>$n$</code>维向量不变的单位矩阵记作 <code>$I_{n}$</code>. 单位矩阵的结构很简单: 所有沿主对角线的元素都是1, 而所有其他位置的元素都是0.</p>
</blockquote>
<p>The <strong>matrix inverse</strong> of <code>$A$</code> is denoted as <code>$A^{-1}$</code>, and it is defined as the matrix such that</p>
<p><code>$$ A^{-1}A = I_{n} \\ $$</code></p>
<blockquote>
<p>矩阵<code>$A$</code>的<strong>矩阵逆(matrix inversion)</strong> 记作 <code>$A^{-1}$</code>, 其定义的矩阵满足如下条件:
<code>$$A^{-1}A = I_{n}$$</code></p>
</blockquote>
<p>We can now solve equation <code>$Ax=b$</code> by the following steps:</p>
<p><code>$$ Ax=b \Rightarrow A^{-1}Ax=A^{-1}b \Rightarrow x = A^{-1}b \\ $$</code></p>
<p>When <code>$A^{-1}$</code> exists, several different algorithms exist for finding it in closed form. In theory, the same inverse matrix can then be used to solve the equation many times for different values of <code>$b$</code> . However, <code>$A^{-1}$</code> is primarily useful as a theoretical tool, and should not actually be used in practice for most software applications. Because <code>$A^{-1}$</code> can be represented with only limited precision on a digital computer, algorithms that make use of the value of <code>$b$</code> can usually obtain more accurate estimates of <code>$x$</code>.</p>
<h2 id="linear-dependence-and-span">Linear Dependence and Span<a hidden class="anchor" aria-hidden="true" href="#linear-dependence-and-span">#</a></h2>
<p>In order for <code>$A^{-1}$</code> to exist, equation <code>$Ax=b$</code> must have exactly one solution for every value of <code>$b$</code>. However, it is also possible for the system of equations to have no solutions or infinitely many solutions for some values of <code>$b$</code>. It is not possible to have more than one but less than infinitely many solutions for a particular <code>$b$</code>; if both <code>$x$</code> and <code>$y$</code> are solutions then</p>
<p><code>$$ z = \alpha x + (1-\alpha)y \\ $$</code></p>
<p>is also a solution for any real <code>$\alpha$</code>.</p>
<p>To analyze how many solutions the equation has, we can think of the columns of <code>$A$</code> as specifying different directions we can travel from the <strong>origin</strong> (the point specified by the vector of all zeros), and determine how many ways there are of reaching <code>$b$</code>. In this view, each element of <code>$x$</code> specifies how far we should travel in each of these directions, with <code>$x_{i}$</code> specifying how far to move in the direction of column <code>$i$</code>:</p>
<p><code>$$ Ax = \sum_{i}x_{i}A_{:,i} \\ $$</code></p>
<p>In general, this kind of operation is called a <strong>linear combination</strong>. Formally, a linear combination of some set of vectors <code>$\{v^{(1)}, \cdots, v^{(n)}\}$</code> is given by multiplying each vector <code>$v^{(i)}$</code> by a corresponding scalar coefficient and adding the results:</p>
<p><code>$$ \sum_{i}c_{i}v^{(i)} \\ $$</code></p>
<p>The <strong>span</strong> of a set of vectors is the set of all points obtainable by linear combination of the original vectors.</p>
<blockquote>
<p>一组向量的<strong>生成子空间(span)</strong> 是原始向量线性组合后所能抵达的点的集合.</p>
</blockquote>
<p>Determining whether <code>$Ax=b$</code> has a solution thus amounts to testing whether <code>$b$</code> is in the span of the columns of <code>$A$</code>. This particular span is known as the <strong>column space</strong> or the <strong>range</strong> of <code>$A$</code>.</p>
<p>A set of vectors is <strong>linearly independent</strong> if no vector in the set is a linear combination of the other vectors. If we add a vector to a set that is a linear combination of the other vectors in the set, the new vector does not add any points to the set’s span. This means that for the column space of the matrix to encompass all of <code>$\mathbb{R}^{m}$</code>, the matrix must contain at least one set of <code>$m$</code> linearly independent columns. This condition is both necessary and sufficient for equation <code>$Ax=b$</code> to have a solution for every value of <code>$b$</code>. Note that the requirement is for a set to have exactly <code>$m$</code> linear independent columns, not at least <code>$m$</code>. No set of <code>$m$</code>-dimensional vectors can have more than m mutually linearly independent columns, but a matrix with more than <code>$m$</code> columns may have more than one such set.</p>
<blockquote>
<p>如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为<strong>线性无关 (linearly independent)</strong> .</p>
</blockquote>
<p>In order for the matrix to have an inverse, we additionally need to ensure that equation <code>$Ax=b$</code> has at most one solution for each value of <code>$b$</code>. To do so, we need to ensure that the matrix has at most <code>$m$</code> columns. Otherwise there is more than one way of parametrizing each solution.</p>
<p>Together, this means that the matrix must be <strong>square</strong>, that is, we require that <code>$m=n$</code> and that all of the columns must be linearly independent. A square matrix with linearly dependent columns is known as <strong>singular</strong>.</p>
<p>If <code>$A$</code> is not square or is square but singular, it can still be possible to solve the equation. However, we can not use the method of matrix inversion to find the  solution.</p>
<h2 id="norms">Norms<a hidden class="anchor" aria-hidden="true" href="#norms">#</a></h2>
<p>Sometimes we need to measure the size of a vector. In machine learning, we usually measure the size of vectors using a function called a <strong>norm</strong>. Formally, the <code>$L^{p}$</code> norm is given by</p>
<p><code>$$ \lVert x \rVert_{p} = \left(\sum_{i}|x_{i}|^{p}\right)^{\frac{1}{p}} \\ $$</code></p>
<p>for <code>$p \in \mathbb{R}$</code>, <code>$p&gt;1$</code>.</p>
<blockquote>
<p>我们经常使用被称为<strong>范数 (norm)</strong> 的函数衡量向量大小. 范数是将向量映射到非负值的函数. 直观上来说, 向量 <code>$x$</code> 的范数衡量从原点到点 <code>$x$</code> 的距离.</p>
</blockquote>
<p>Norms, including the <code>$L^{p}$</code> norm, are functions mapping vectors to non-negative values. On an intuitive level, the norm of a vector <code>$x$</code> measures the distance from the origin to the point <code>$x$</code>. More rigorously, a norm is any function <code>$f$</code> that satisfies the following properties:</p>
<ul>
<li><code>$f(x) = 0 \Rightarrow x = 0$</code></li>
<li><code>$f(x+y) \leq f(x) + f(y)$</code> (the triangle inequality)</li>
<li><code>$\forall \alpha \in \mathbb{R}, f(\alpha x) = |\alpha|f(x)$</code></li>
</ul>
<blockquote>
<p><strong>范数 (norm)</strong> 满足以下性质：</p>
<ul>
<li><code>$f(x) = 0 \Rightarrow x = 0$</code> <br></li>
<li><code>$f(x+y) \leq f(x) + f(y)$</code> (满足三角不等式, 或称次可加性)<br></li>
<li><code>$\forall \alpha \in \mathbb{R}, f(\alpha x) = |\alpha|f(x)$</code> (具有绝对一次齐次性)<br></li>
</ul>
</blockquote>
<p>The <code>$L^{2}$</code> norm, with <code>$p=2$</code>, is known as the <strong>Euclidean norm</strong>. It is simply the Euclidean distance from the origin to the point identified by <code>$x$</code>. The <code>$L^{2}$</code> norm is used so frequently in machine learning that it is often denoted simply as <code>$\lVert x \rVert$</code>, with the subscript 2 omitted. It is also common to measure the size of a vector using the squared <code>$L^{2}$</code> norm, which can be calculated simply as <code>$x^{T}x$</code>.</p>
<p><code>$$ \lVert x \rVert_{2} = \sqrt{\sum_{i}|x_{i}|^{2}} \\ $$</code></p>
<blockquote>
<p>当 <code>$p=2$</code> 时，<code>$L^{2}$</code> 范数被称为<strong>欧几里得范数(Euclidean norm)</strong> .它表示从原点出发到向量 <code>$x$</code> 确定的点的欧几里得距离.</p>
</blockquote>
<p>The <code>$L^{1}$</code> norm is commonly used in machine learning when the difference between zero and nonzero elements is very important. Every time an element of <code>$x$</code> moves away from 0 by <code>$\varepsilon$</code>, the <code>$L^{1}$</code> norm increases by <code>$\varepsilon$</code>. The <code>$L^{1}$</code> norm may be simplified to</p>
<p><code>$$ \lVert x \rVert_{1} = \sum_{i}|x_{i}| \\ $$</code></p>
<p>One other norm that commonly arises in machine learning is the <code>$L^{\infty}$</code> norm, also known as the <strong>max norm</strong>. This norm simplifies to the absolute value of the element with the largest magnitude in the vector,</p>
<p><code>$$ \lVert x \rVert_{\infty} = max_{i}|x_{i}| \\ $$</code></p>
<p>Sometimes we may also wish to measure the size of a matrix. In the context of deep learning, the most common way to do this is with the otherwise obscure
<strong>Frobenius norm</strong>:</p>
<p><code>$$ \lVert x \rVert_{F} = \sqrt{\sum_{i,j}A_{i,j}^{2}} \\ $$</code></p>
<p>The dot product of two vectors can be rewritten in terms of norms. Specifically,</p>
<p><code>$$ x^{T}y = \lVert x \rVert_{2}\lVert y \rVert_{2} \cos{\theta} \\ $$</code></p>
<p>where <code>$\theta$</code> is the angle between <code>$x$</code> and <code>$y$</code>.</p>
<h2 id="special-kinds-of-matrices-and-vectors">Special Kinds of Matrices and Vectors<a hidden class="anchor" aria-hidden="true" href="#special-kinds-of-matrices-and-vectors">#</a></h2>
<p>Some special kinds of matrices and vectors are particularly useful.</p>
<p><strong>Diagonal matrices</strong> consist mostly of zeros and have non-zero entries only along the main diagonal. Formally, a matrix <code>$D$</code> is diagonal if and only if <code>$D_{i,j}=0$</code> for all <code>$i \neq j$</code>. We have already seen one example of a diagonal matrix: the identity matrix, where all of the diagonal entries are 1. We write <code>$diag(v)$</code> to denote a square diagonal matrix whose diagonal entries are given by the entries of the vector <code>$v$</code>, e.g.,</p>
<p><code>$$ v = \begin{bmatrix} a_{1} \\ a_{2} \\ a_{3} \\ \end{bmatrix} \Rightarrow diag(v) = \begin{bmatrix} a_{1} &amp; 0 &amp; 0 \\ 0 &amp; a_{2} &amp; 0 \\ 0 &amp; 0 &amp; a_{3} \\ \end{bmatrix} $$</code></p>
<p>Diagonal matrices are of interest in part because multiplying by a diagonal matrix is very <strong>computationally efficient</strong>. To compute <code>$diag(v)x$</code>, we only need to scale each element <code>$x_{i}$</code> by <code>$v_{i}$</code>. In other words, <code>$diag(v)x = v \odot x$</code>. Inverting a square diagonal matrix is also efficient. The inverse exists only if every diagonal entry is nonzero, <code>$diag(v)^{-1}= diag([\frac{1}{v_{1}}, \cdots, \frac{1}{v_{n}}]^{T})$</code>.</p>
<blockquote>
<p><strong>对角矩阵(diagonal matrix)</strong> 只在主对角线上含有非零元素, 其他位置都是零.</p>
</blockquote>
<p>A <strong>symmetric matrix</strong> is any matrix that is equal to its own transpose:</p>
<p><code>$$ A = A^{T} \\ $$</code></p>
<p>For example,</p>
<p><code>$$ A = A^{T} = \begin{bmatrix} 1 &amp; 2 \\ 2 &amp; 3 \\ \end{bmatrix} \ \ \ \ \ \ \ \ B = B^{T} = \begin{bmatrix} 5 &amp; 6 &amp; 7 \\ 6 &amp; 3 &amp; 2 \\ 7 &amp; 2 &amp; 1 \\ \end{bmatrix} $$</code></p>
<p>Symmetric matrices often arise when the entries are generated by some function of two arguments that does not depend on the order of the arguments. For example, if <code>$A$</code> is a matrix of distance measurements, with <code>$A_{i,j}$</code> giving the distance from point <code>$i$</code> to point <code>$j$</code>, then <code>$A_{i,j} = A_{j,i}$</code> because distance functions are symmetric.</p>
<blockquote>
<p><strong>对称矩阵(symmetric matrix)</strong> 是转置和自己相等的矩阵.</p>
</blockquote>
<p>A <strong>unit vector</strong> is a vector with unit norm:</p>
<p><code>$$ \lVert x \rVert_{2} = 1 \\ $$</code></p>
<p>A vector <code>$x$</code> and a vector <code>$y$</code> are orthogonal to each other if <code>$x^{T}y=0$</code>. If both vectors have nonzero norm, this means that they are at a 90 degree angle to each other. In <code>$\mathbb{R}^{n}$</code>, at most <code>$n$</code> vectors may be mutually orthogonal with nonzero norm. If the vectors are not only orthogonal but also have unit norm, we call them <strong>orthonormal</strong>.</p>
<blockquote>
<p><strong>单位向量(unit vector)</strong> 是具有<strong>单位范数(unit norm)</strong> 的向量. 如果 <code>$x^{T}y=0$</code>，那么向量 <code>$x$</code> 和向量 <code>$y$</code> 互相<strong>正交(orthogonal)</strong> . 如果两个向量都有非零范数, 那么这两个向量之间的夹角是90度. 如果这些向量不仅互相正交，并且范数都为 1，那么我们称它们是<strong>标准正交(orthonormal)</strong> .</p>
</blockquote>
<p>An <strong>orthogonal matrix</strong> is a square matrix whose rows are mutually orthonormal and whose columns are mutually orthonormal:</p>
<p><code>$$ A^{T}A = AA^{T} = I \\ $$</code></p>
<p>This implies that</p>
<p><code>$$ A^{-1} = A^{T} \\ $$</code></p>
<p>so orthogonal matrices are of interest because their inverse is very cheap to compute. Pay careful attention to the definition of orthogonal matrices. Counterintuitively, their rows are not merely orthogonal but fully orthonormal. There is no special term for a matrix whose rows or columns are orthogonal but not orthonormal.</p>
<h2 id="eigendecomposition">Eigendecomposition<a hidden class="anchor" aria-hidden="true" href="#eigendecomposition">#</a></h2>
<p>Much as we can discover something about the true nature of an integer by decomposing it into prime factors, we can also decompose matrices in ways that show us information about their functional properties that is not obvious from the representation of the matrix as an array of elements.</p>
<p>One of the most widely used kinds of matrix decomposition is called <strong>eigendecomposi-tion</strong>, in which we decompose a matrix into a set of eigenvectors and eigenvalues.</p>
<p>An <strong>eigenvector</strong> of a square matrix <code>$A$</code> is a non-zero vector <code>$v$</code> such that multiplication by <code>$A$</code> alters only the scale of <code>$v$</code>:</p>
<p><code>$$ Av = \lambda v \\ $$</code></p>
<p>The scalar <code>$\lambda$</code> is known as the <strong>eigenvalue</strong> corresponding to this eigenvector. If <code>$v$</code> is an eigenvector of <code>$A$</code>, then so is any rescaled vector <code>$sv$</code> for <code>$s \in \mathbb{R}$</code>, <code>$s \neq 0$</code>. Moreover, <code>$sv$</code> still has the same eigenvalue. For this reason, we usually only look for unit eigenvectors.</p>
<blockquote>
<p><strong>特征分解(eigendecomposition)</strong> 是使用最广的矩阵分解之一, 即我们将矩阵分解成一组特征向量和特征值. 方阵 <code>$A$</code> 的<strong>特征向量(eigenvector)</strong> 是指与 <code>$A$</code> 相乘后相当于对该向量进行缩放的非零向量 <code>$v$</code>:
<code>$$Av = \lambda v \\$$</code>
标量 <code>$\lambda$</code> 被称为这个特征向量对应的<strong>特征值(eigenvalue)</strong> .</p>
</blockquote>
<p>Suppose that a matrix <code>$A$</code> has <code>$n$</code> linearly independent eigenvectors, <code>$\{v^{(1)}, \cdots, v^{(n)}\}$</code>, with corresponding eigenvalues <code>$\{\lambda_{1}, \cdots, \lambda_{n}\}$</code>. We may concatenate all of the eigenvectors to form a matrix <code>$V$</code> with one eigenvector per column: <code>$V=[v^{(1)}, \cdots, v^{(n)}]$</code>. Likewise, we can concatenate the eigenvalues to form a vector <code>$\lambda = [\lambda_{1}, \cdots, \lambda_{n}]^{T}$</code>. The <strong>eigendecomposi-tion</strong> of <code>$A$</code> is then given by</p>
<p><code>$$ A = V diag(\lambda)V^{-1} \\ $$</code></p>
<blockquote>
<p><code>$A$</code>的<strong>特征分解(eigendecomposition)</strong> 可以记作:
<code>$$A = V diag(\lambda)V^{-1} $$</code></p>
</blockquote>
<p>We have seen that constructing matrices with specific eigenvalues and eigenvectors allows us to stretch space in desired directions. However, we often want to decompose matrices into their eigenvalues and eigenvectors. Doing so can help us to analyze certain properties of the matrix, much as <strong>decomposing</strong> an integer into its prime factors can help us understand the behavior of that integer. Not every matrix can be decomposed into eigenvalues and eigenvectors. In some cases, the decomposition exists, but may involve complex rather than real numbers.</p>
<h2 id="singular-value-decomposition">Singular Value Decomposition<a hidden class="anchor" aria-hidden="true" href="#singular-value-decomposition">#</a></h2>
<p>We already known how to decompose a matrix into eigenvectors and eigenvalues. The <strong>singular value decomposition</strong> (SVD) provides another way to factorize a matrix, into <strong>singular vectors</strong> and <strong>singular values</strong>. The SVD allows us to discover some of the same kind of information as the eigendecomposition. However, the SVD is more generally applicable. Every real matrix has a singular value decomposition, but the same is not true of the eigenvalue decomposition. For example, if a matrix is not square, the eigendecom-position is not defined, and we must use a singular value decomposition instead.</p>
<p>Recall that the eigendecomposition involves analyzing a matrix <code>$A$</code> to discover a matrix <code>$V$</code> of eigenvectors and a vector of eigenvalues <code>$\lambda$</code> such that we can rewrite <code>$A$</code> as</p>
<p><code>$$ A = V diag(\lambda)V^{-1} \\ $$</code></p>
<p>The singular value decomposition is similar, except this time we will write <code>$A$</code> as a product of three matrices:</p>
<p><code>$$ A = UDV^{T} \\ $$</code></p>
<p>Suppose that <code>$A$</code> is an <code>$m \times n$</code> matrix. Then <code>$U$</code> is defined to be an <code>$m \times m$</code> matrix, <code>$D$</code> to be an <code>$m \times n$</code> matrix, and <code>$V$</code> to be an <code>$n \times n$</code> matrix.</p>
<blockquote>
<p><strong>奇异值分解(singular value decomposition, SVD)</strong>, 将矩阵分解为<strong>奇异向量(singular vector)</strong> 和<strong>奇异值(singular value)</strong> :
<code>$$A = UDV^{T} \\$$</code>
如果 <code>$A$</code> 是一个 <code>$m \times n$</code> 的矩阵. 那么 <code>$U$</code> 是一个 <code>$m \times m$</code> 的矩阵, <code>$D$</code> 是一个 <code>$m \times n$</code> 的矩阵, <code>$V$</code> 是一个 <code>$n \times n$</code> 的矩阵.</p>
</blockquote>
<p>Each of these matrices is defined to have a special structure. The matrices <code>$U$</code> and <code>$V$</code> are both defined to be orthogonal matrices. The matrix <code>$D$</code> is defined to be a diagonal matrix. Note that <code>$D$</code> is not necessarily square.</p>
<p>The elements along the diagonal of <code>$D$</code> are known as the <strong>singular values</strong> of the matrix <code>$A$</code>. The columns of <code>$U$</code> are known as the <strong>left-singular vectors</strong>. The columns of <code>$V$</code> are known as as the <strong>right-singular vectors</strong>.</p>
<h2 id="the-trace-operator">The Trace Operator<a hidden class="anchor" aria-hidden="true" href="#the-trace-operator">#</a></h2>
<p>The trace operator gives the sum of all of the diagonal entries of a matrix:</p>
<p><code>$$ Tr(A) = \sum_{i}A_{i,i} \\ $$</code></p>
<blockquote>
<p><strong>迹运算(trace operator)</strong> 返回的是矩阵对角元素的和.</p>
</blockquote>
<p>For example, let <code>$A$</code> be a matrix, with</p>
<p><code>$$ A = \begin{bmatrix} a_{1,1} &amp; a_{1,2}  \\ a_{2,1} &amp; a_{2,2}  \\ \end{bmatrix} $$</code></p>
<p>Then,</p>
<p><code>$$ Tr(A) = \sum_{i=1}^{2}a_{i,i} = a_{1,1} + a_{2,2} $$</code></p>
<p>The trace operator is useful for a variety of reasons. Some operations that are difficult to specify without resorting to summation notation can be specified using  matrix products and the trace operator. For example, the trace operator provides an alternative way of writing the Frobenius norm of a matrix:</p>
<p><code>$$ \lVert x \rVert_{F} = \sqrt{Tr(AA^{T})} \\ $$</code></p>
<p>Writing an expression in terms of the trace operator opens up opportunities to manipulate the expression using many useful identities. For example, the trace operator is invariant to the transpose operator:</p>
<p><code>$$ Tr(A) = Tr(A^{T}) \\ $$</code></p>
<p>The trace of a square matrix composed of many factors is also invariant to moving the last factor into the first position, if the shapes of the corresponding matrices allow the resulting product to be defined:</p>
<p><code>$$ Tr(ABC) = Tr(CAB) = Tr(BCA) \\ $$</code></p>
<p>This invariance to cyclic permutation holds even if the resulting product has a different shape. For example, for <code>$A \in \mathbb{R}^{m \times n}$</code> and <code>$B \in \mathbb{R}^{n \times m}$</code>, we have</p>
<p><code>$$ Tr(AB) = Tr(BA) \\ $$</code></p>
<p>even though  <code>$AB \in \mathbb{R}^{m \times m}$</code> and <code>$BA \in \mathbb{R}^{n \times n}$</code></p>
<p>Another useful fact to keep in mind is that a scalar is its own trace: <code>$a = Tr(a)$</code>.</p>
<h2 id="the-determinant">The Determinant<a hidden class="anchor" aria-hidden="true" href="#the-determinant">#</a></h2>
<p>The determinant of a square matrix, denoted <code>$det(A)$</code>, is a function mapping matrices to real scalars. The determinant is equal to the product of all the eigenvalues of the matrix. The absolute value of the determinant can be thought of as a measure of how much multiplication by the matrix expands or contracts space. If the determinant is 0, then space is contracted completely along at least one dimension, causing it to lose all of its volume. If the determinant is 1, then the transformation preserves volume.</p>
<blockquote>
<p><strong>行列式(determinant)</strong> 是一个将方阵映射到实数的函数. 行列式等于矩阵特征值的乘积.</p>
</blockquote>
<p>For example, for a <code>$2 \times 2$</code> matrix:</p>
<p><code>$$ A = \begin{bmatrix} a &amp; b  \\ c &amp; d  \\ \end{bmatrix} $$</code></p>
<p>The determinant is:</p>
<p><code>$$ det(A) = |A| = ad - bc $$</code></p>
<h2 id="jacobian-and-hessian-matrices">Jacobian and Hessian Matrices<a hidden class="anchor" aria-hidden="true" href="#jacobian-and-hessian-matrices">#</a></h2>
<p>Sometimes we need to find all of the partial derivatives of a function whose input and output are both vectors. The matrix containing all such partial derivatives is known as a <strong>Jacobian matrix</strong>. Specifically, if we have a function <code>$f: \mathbb{R}^{m} \to \mathbb{R}^{n}$</code>, then the Jacobian matrix <code>$J \in  \mathbb{R}^{n \times m}$</code> of <code>$f$</code> is defined such that <code>$J_{i,j}=\frac{\partial}{\partial x_{j}}f(x)_{i}$</code>.</p>
<p><code>$$ J = \begin{bmatrix} \frac{\partial f}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial f}{\partial x_{n}} \\ \end{bmatrix} =   \begin{bmatrix} \nabla^{T}f_{1} \\ \vdots \\ \nabla^{T}f_{m} \\ \end{bmatrix} = \begin{bmatrix} \frac{\partial f_{1}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial f_{1}}{\partial x_{n}} \\ \vdots &amp; \ddots &amp; \vdots \\ \frac{\partial f_{m}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial f_{m}}{\partial x_{n}} \\ \end{bmatrix} \\ $$</code></p>
<blockquote>
<p>有时我们需要计算输入和输出都为向量的函数的所有偏导数.包含所有这样的偏导数的矩阵被称为 <strong>Jacobian 矩阵</strong>.</p>
</blockquote>
<p>We are also sometimes interested in a derivative of a derivative. This is known as a second derivative. For example, for a function <code>$f: \mathbb{R}^{n} \to \mathbb{R}$</code>, the derivative with respect to <code>$x_{i}$</code> of the derivative of <code>$f$</code> with respect to <code>$x_{j}$</code> is denoted as <code>$\frac{\partial^{2}}{\partial x_{i}\partial x_{j}}f$</code>. In a single dimension, we can denote <code>$\frac{d^{2}}{dx^{2}}f$</code> by <code>$f''(x)$</code>. The second derivative tells us how the first derivative will change as we vary the input. This is important because it tells us whether a gradient step will cause as much of an improvement as we would expect based on the gradient alone. We can think of the second derivative as measuring <strong>curvature</strong>.</p>
<p>When our function has multiple input dimensions, there are many second derivatives. These derivatives can be collected together into a matrix called the <strong>Hessian matrix</strong>. The Hessian matrix <code>$H(f)(x)$</code> is defined such that <code>$H(f)(x)_{i,j} = \frac{\partial^{2}}{\partial x_{i}\partial x_{j}}f(x)$</code></p>
<p><code>$$ H(f)(x)_{i,j} = \begin{bmatrix} \frac{\partial^{2} f}{\partial x_{1}^{2}} &amp; \frac{\partial^{2} f}{\partial x_{1}\partial x_{2}} &amp; \cdots &amp; \frac{\partial^{2} f}{\partial x_{1}\partial x_{n}} \\ \frac{\partial^{2} f}{\partial x_{2}\partial x_{1}} &amp; \frac{\partial^{2} f}{\partial x_{2}^{2}} &amp; \cdots &amp; \frac{\partial^{2} f}{\partial x_{2}\partial x_{n}} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \frac{\partial^{2} f}{\partial x_{n}\partial x_{1}} &amp; \frac{\partial^{2} f}{\partial x_{n}\partial x_{2}} &amp; \cdots &amp; \frac{\partial^{2} f}{\partial x_{n}^{2}} \\ \end{bmatrix} \\ $$</code></p>
<p>Equivalently, the Hessian is the Jacobian of the gradient.</p>
<blockquote>
<p>当我们的函数具有多维输入时,二阶导数也有很多.我们可以将这些导数合并成一个矩阵,称为 <strong>Hessian 矩阵</strong>.</p>
</blockquote>
<p>Anywhere that the second partial derivatives are continuous, the differential operators are commutative, i.e. their order can be swapped:</p>
<p><code>$$ \frac{\partial^{2}}{\partial x_{i}\partial x_{j}}f(x)=\frac{\partial^{2}}{\partial x_{j}\partial x_{i}}f(x) \\ $$</code></p>
<p>This implies that <code>$H_{i,j}=h_{j,i}$</code>, so the Hessian matrix is symmetric at such points. Most of the functions we encounter in the context of deep learning have a symmetric Hessian almost everywhere. Because the Hessian matrix is real and symmetric, we can decompose it into a set of real eigenvalues and an orthogonal basis of eigenvectors. The second derivative in a specific direction represented by a unit vector <code>$f$</code> is given by <code>$d^{T}Hd$</code>. When <code>$d$</code> is an eigenvector of <code>$H$</code> , the second derivative in that direction is given by the corresponding eigenvalue. For other directions of <code>$d$</code>, the directional second derivative is a weighted average of all of the eigenvalues, with weights between 0 and 1, and eigenvectors that have smaller angle with <code>$d$</code> receiving more weight. The maximum eigenvalue determines the maximum second derivative and the minimum eigenvalue determines the minimum second derivative.</p>
<h2 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h2>
<p>[1]  Goodfellow, I., Bengio, Y., &amp; Courville, A. (2016, Nov 18). Deep Learning. <a href="https://www.deeplearningbook.org/contents/linear_algebra.html">https://www.deeplearningbook.org/contents/linear_algebra.html</a>.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://followb1ind1y.github.io/tags/linear-algebra/">Linear Algebra</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://followb1ind1y.github.io/posts/applied_math_and_ml_basics/02_probability_and_information_theory_for_ml/">
    <span class="title">« Prev Page</span>
    <br>
    <span>[ML Basics] Probability and Information Theory</span>
  </a>
  <a class="next" href="https://followb1ind1y.github.io/posts/machine_learning/12_boosting/">
    <span class="title">Next Page »</span>
    <br>
    <span>Boosting</span>
  </a>
</nav>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Linear Algebra on twitter"
        href="https://twitter.com/intent/tweet/?text=%5bML%20Basics%5d%20Linear%20Algebra&amp;url=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f01_linear_algebra_for_ml%2f&amp;hashtags=LinearAlgebra">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Linear Algebra on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f01_linear_algebra_for_ml%2f&amp;title=%5bML%20Basics%5d%20Linear%20Algebra&amp;summary=%5bML%20Basics%5d%20Linear%20Algebra&amp;source=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f01_linear_algebra_for_ml%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Linear Algebra on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f01_linear_algebra_for_ml%2f&title=%5bML%20Basics%5d%20Linear%20Algebra">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Linear Algebra on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f01_linear_algebra_for_ml%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Linear Algebra on whatsapp"
        href="https://api.whatsapp.com/send?text=%5bML%20Basics%5d%20Linear%20Algebra%20-%20https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f01_linear_algebra_for_ml%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Linear Algebra on telegram"
        href="https://telegram.me/share/url?text=%5bML%20Basics%5d%20Linear%20Algebra&amp;url=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f01_linear_algebra_for_ml%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://followb1ind1y.github.io/">Followb1ind1y</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script src="//yihui.org/js/math-code.js"></script>


<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>

</html>
