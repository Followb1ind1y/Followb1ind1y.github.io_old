<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[ML Basics] Machine Learning Basics | Followb1ind1y</title>
<meta name="keywords" content="Machine Learning" />
<meta name="description" content="Learning Algorithms A machine learning algorithm is an algorithm that is able to learn from data. But what do we mean by learning? Mitchell (1997) provides the definition &ldquo;A computer program is said to learn from experience $E$ with respect to some class of tasks $T$ and performance measure $P$, if its performance at tasks in $T$, as measured by $P$, improves with experience $E$.&rdquo;
The Task, $T$ Machine learning allows us to tackle tasks that are too difficult to solve with fixed programs written and designed by human beings.">
<meta name="author" content="Followb1ind1y">
<link rel="canonical" href="https://followb1ind1y.github.io/posts/applied_math_and_ml_basics/04_machine_learning_basics_for_ml/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.e70e973962a3e34880adaea2030c2ba5d772c1d55b6db8842bf38c6db6dae5fd.css" integrity="sha256-5w6XOWKj40iAra6iAwwrpddywdVbbbiEK/OMbbba5f0=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://followb1ind1y.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://followb1ind1y.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://followb1ind1y.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://followb1ind1y.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://followb1ind1y.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.83.1" />
<meta property="og:title" content="[ML Basics] Machine Learning Basics" />
<meta property="og:description" content="Learning Algorithms A machine learning algorithm is an algorithm that is able to learn from data. But what do we mean by learning? Mitchell (1997) provides the definition &ldquo;A computer program is said to learn from experience $E$ with respect to some class of tasks $T$ and performance measure $P$, if its performance at tasks in $T$, as measured by $P$, improves with experience $E$.&rdquo;
The Task, $T$ Machine learning allows us to tackle tasks that are too difficult to solve with fixed programs written and designed by human beings." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://followb1ind1y.github.io/posts/applied_math_and_ml_basics/04_machine_learning_basics_for_ml/" /><meta property="og:image" content="https://followb1ind1y.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-30T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-06-30T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://followb1ind1y.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="[ML Basics] Machine Learning Basics"/>
<meta name="twitter:description" content="Learning Algorithms A machine learning algorithm is an algorithm that is able to learn from data. But what do we mean by learning? Mitchell (1997) provides the definition &ldquo;A computer program is said to learn from experience $E$ with respect to some class of tasks $T$ and performance measure $P$, if its performance at tasks in $T$, as measured by $P$, improves with experience $E$.&rdquo;
The Task, $T$ Machine learning allows us to tackle tasks that are too difficult to solve with fixed programs written and designed by human beings."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://followb1ind1y.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[ML Basics] Machine Learning Basics",
      "item": "https://followb1ind1y.github.io/posts/applied_math_and_ml_basics/04_machine_learning_basics_for_ml/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[ML Basics] Machine Learning Basics",
  "name": "[ML Basics] Machine Learning Basics",
  "description": "Learning Algorithms A machine learning algorithm is an algorithm that is able to learn from data. But what do we mean by learning? Mitchell (1997) provides the definition \u0026ldquo;A computer program is said to learn from experience $E$ with respect to some class of tasks $T$ and performance measure $P$, if its performance at tasks in $T$, as measured by $P$, improves with experience $E$.\u0026rdquo;\nThe Task, $T$ Machine learning allows us to tackle tasks that are too difficult to solve with fixed programs written and designed by human beings.",
  "keywords": [
    "Machine Learning"
  ],
  "articleBody": "Learning Algorithms A machine learning algorithm is an algorithm that is able to learn from data. But what do we mean by learning? Mitchell (1997) provides the definition “A computer program is said to learn from experience $E$ with respect to some class of tasks $T$ and performance measure $P$, if its performance at tasks in $T$, as measured by $P$, improves with experience $E$.”\nThe Task, $T$ Machine learning allows us to tackle tasks that are too difficult to solve with fixed programs written and designed by human beings. From a scientific and philosophical point of view, machine learning is interesting because developing our understanding of machine learning entails developing our understanding of the principles that underlie intelligence.\nIn this relatively formal definition of the word “task,” the process of learning itself is not the task. Learning is our means of attaining the ability to perform the task.\nMachine learning tasks are usually described in terms of how the machine learning system should process an example. An example is a collection of features that have been quantitatively measured from some object or event that we want the machine learning system to process. We typically represent an example as a vector $x \\in \\mathbb{R}$ where each entry $x_{i}$ of the vector is another feature. For example, the features of an image are usually the values of the pixels in the image.\n 通常机器学习任务定义为机器学习系统应该如何处理 样本(example). 样本是指我们从某些希望机器学习系统处理的对象或事件中收集到的已经量化的 特征 (feature) 的集合.\n Many kinds of tasks can be solved with machine learning. Some of the most common machine learning tasks include the following:\n Classification: In this type of task, the computer program is asked to specify which of $k$ categories some input belongs to. To solve this task, the learning algorithm is usually asked to produce a function $f: \\mathbb{R}^{n} \\to \\{1, \\cdots,k \\}$. When $y=f(x)$, the model assigns an input described by vector $x$ to a category identified by numeric code $y$. There are other variants of the classification task, for example, where $f$ outputs a probability distribution over classes. An example of a classification task is object recognition, where the input is an image (usually described as a set of pixel brightness values), and the output is a numeric code identifying the object in the image. Object recognition is the same basic technology that allows computers to recognize faces (Taigman et al., 2014), which can be used to automatically tag people in photo collections and allow computers to interact more naturally with their users.   分类: 在这类任务中, 计算机程序需要指定某些输入属于 $k$ 类中的哪一类. 为了完成这个任务, 学习算法通常会返回一个函数 $f: \\mathbb{R}^{n} \\to \\{1, \\cdots,k \\}$.当 $y=f(x)$ 时, 模型将向量 $x$ 所代表的输入分类到数字码 $y$ 所代表的类别.还有一些其他的分类问题, 例如, $f$ 输出的是不同类别的概率分布. 代表示例有： 人脸识别.\n  Classification with missing inputs: Classification becomes more challenging if the computer program is not guaranteed that every measurement in its input vector will always be provided. In order to solve the classification task, the learning algorithm only has to define a single function mapping from a vector input to a categorical output. When some of the inputs may be missing, rather than providing a single classification function, the learning algorithm must learn a set of functions. Each function corresponds to classifying $x$ with a different subset of its inputs missing. This kind of situation arises frequently in medical diagnosis, because many kinds of medical tests are expensive or invasive. One way to efficiently define such a large set of functions is to learn a probability distribution over all of the relevant variables, then solve the classification task by marginalizing out the missing variables. With $n$ input variables, we can now obtain all $2^{n}$ different classification functions needed for each possible set of missing inputs, but we only need to learn a single function describing the joint probability distribution.   输入缺失分类: 当输入向量的每个度量不被保证的时候, 分类问题将会变得更有挑战性. 为了解决分类任务, 学习算法只需要定义一个从输入向量映射到输出类别的函数. 当一些输入可能丢失时, 学习算法必须学习一组函数, 而不是单个分类函数. 每个函数对应着分类具有不同缺失输入子集的 $x$. 这种情况在 医疗诊断中经常出现, 因为很多类型的医学测试是昂贵的, 对身体有害的.\n  Regression: In this type of task, the computer program is asked to predict a numerical value given some input. To solve this task, the learning algorithm is asked to output a function $f:\\mathbb{R}^{n}\\to\\mathbb{R}$. This type of task is similar to classification, except that the format of output is different. An example of a regression task is the prediction of the expected claim amount that an insured person will make (used to set insurance premiums), or the prediction of future prices of securities. These kinds of predictions are also used for algorithmic trading.   回归: 在这类任务中, 计算机程序需要对给定输入预测数值.为了解决这个任务, 学习算法需要输出函数 $f:\\mathbb{R}^{n}\\to\\mathbb{R}$.除了返回结果的形式不一样外, 这类问题和分类问题是很像的. 代表示例有：预测证券未来的价格.\n  Transcription: In this type of task, the machine learning system is asked to observe a relatively unstructured representation of some kind of data and transcribe it into discrete, textual form. For example, in optical character recognition, the computer program is shown a photograph containing an image of text and is asked to return this text in the form of a sequence of characters (e.g., in ASCII or Unicode format). Another example is speech recognition, where the computer program is provided an audio waveform and emits a sequence of characters or word ID codes describing the words that were spoken in the audio recording. Deep learning is a crucial component of modern speech recognition systems used at major companies.   转录: 这类任务中, 机器学习系统观测一些相对非结构化表示的数据, 并转录信息为离散的文本形式.代表示例有：光学字符识别要求计算机程序根据文本图片返回文字序列、语音识别.\n  Machine translation: In a machine translation task, the input already consists of a sequence of symbols in some language, and the computer program must convert this into a sequence of symbols in another language. This is commonly applied to natural languages, such as translating from English to French.   机器翻译: 在机器翻译任务中, 输入是一种语言的符号序列, 计算机程序必须将其转化成另一种语言的符号序列. 代表示例有：英语翻译成法语.\n  Structured output: Structured output tasks involve any task where the output is a vector (or other data structure containing multiple values) with important relationships between the different elements. This is a broad category, and subsumes the transcription and translation tasks described above, but also many other tasks. One example is parsing—mapping a natural language sentence into a tree that describes its grammatical structure and tagging nodes of the trees as being verbs, nouns, or adverbs, and so on. Another example is pixel-wise segmentation of images, where the computer program assigns every pixel in an image to a specific category.   结构化输出: 结构化输出任务的输出是向量或者其他包含多个值的数据结构, 并且构成输出的这些不同元素间具有重要关系.这是一个很大的范畴, 包括上述转录任务和翻译任务在内的很多其他任务. 代表示例有：语法分析、图像的像素级分割, 将每一个像素分配到特定类别.\n  Anomaly detection: In this type of task, the computer program sifts through a set of events or objects, and flags some of them as being unusual or atypical. An example of an anomaly detection task is credit card fraud detection. By modeling your purchasing habits, a credit card company can detect misuse of your cards. If a thief steals your credit card or credit card information, the thief’s purchases will often come from a different probability distribution over purchase types than your own. The credit card company can prevent fraud by placing a hold on an account as soon as that card has been used for an uncharacteristic purchase.   异常检测: 在这类任务中, 计算机程序在一组事件或对象中筛选, 并标记不正常或非典型的个体. 异常检测任务的一个示例是信用卡欺诈检测.\n  Synthesis and sampling: In this type of task, the machine learning algorithm is asked to generate new examples that are similar to those in the training data. Synthesis and sampling via machine learning can be useful for media applications where it can be expensive or boring for an artist to generate large volumes of content by hand. For example, video games can automatically generate textures for large objects or landscapes, rather than requiring an artist to manually label each pixel.   合成和采样: 在这类任务中, 机器学习程序生成一些和训练数据相似的新样本. 通过机器学习, 合成和采样可能在媒体应用中非常有用, 可以避免艺术家大量昂贵或者乏味费时的手动工作. 例如, 视频游戏可以自动生成大型物体或风景的纹理, 而不是让艺术家手动标记每个像素.\n  Imputation of missing values: In this type of task, the machine learning algorithm is given a new example $x \\in \\mathbb{R}^{n}$, but with some entries $x_{i}$ of $x$ missing. The algorithm must provide a prediction of the values of the missing entries.   缺失值填补: 在这类任务中, 机器学习算法给定一个新样本 $x \\in \\mathbb{R}^{n}$, $x$ 中某些元素 $x_{i}$ 缺失.算法必须填补这些缺失值.\n  Denoising: In this type of task, the machine learning algorithm is given in input a corrupted example $\\tilde{x} \\in \\mathbb{R}^{n}$ obtained by an unknown corruption process from a clean example $x\\in \\mathbb{R}^{n}$. The learner must predict the clean example $x$ from its corrupted version $\\tilde{x}$, or more generally predict the conditional probability distribution $p(x \\ | \\ \\tilde{x})$.   去噪: 在这类任务中, 机器学习算法的输入是, 干净样本 $x\\in \\mathbb{R}^{n}$ 经过未知损坏过程后得到的损坏样本 $\\tilde{x} \\in \\mathbb{R}^{n}$.算法根据损坏后的样本 $\\tilde{x}$ 预测干净的样本 $x$, 或者更一般地预测条件概率分布 $p(x \\ | \\ \\tilde{x})$.\n Of course, many other tasks and types of tasks are possible. The types of tasks we list here are intended only to provide examples of what machine learning can do, not to define a rigid taxonomy of tasks.\nThe Performance Measure, $P$ In order to evaluate the abilities of a machine learning algorithm, we must design a quantitative measure of its performance. Usually this performance measure $P$ is specific to the task $T$ being carried out by the system.\nFor tasks such as classification, classification with missing inputs, and transcription, we often measure the accuracy of the model. Accuracy is just the proportion of examples for which the model produces the correct output. We can also obtain equivalent information by measuring the error rate, the proportion of examples for which the model produces an incorrect output. We often refer to the error rate as the expected 0-1 loss. The 0-1 loss on a particular example is 0 if it is correctly classified and 1 if it is not. For tasks such as density estimation, it does not make sense to measure accuracy, error rate, or any other kind of 0-1 loss. Instead, we must use a different performance metric that gives the model a continuous-valued score for each example. The most common approach is to report the average log-probability the model assigns to some examples.\n 对于诸如分类、缺失输入分类和转录任务, 我们通常度量模型的 准确率(accuracy).准确率是指该模型输出正确结果的样本比率. 我们也可以通过 错误率(error rate) 得到相同的信息. 错误率是指该模型输出错误结果的样本比率.\n Usually we are interested in how well the machine learning algorithm performs on data that it has not seen before, since this determines how well it will work when deployed in the real world. We therefore evaluate these performance measures using a test set of data that is separate from the data used for training the machine learning system.\nThe choice of performance measure may seem straightforward and objective, but it is often difficult to choose a performance measure that corresponds well to the desired behavior of the system.\nThe Experience, $E$ Machine learning algorithms can be broadly categorized as unsupervised or supervised by what kind of experience they are allowed to have during the learning process.\nMost of the learning algorithms can be understood as being allowed to experience an entire dataset. A dataset is a collection of many examples. Sometimes we will also call examples data points.\nUnsupervised learning algorithms experience a dataset containing many features, then learn useful properties of the structure of this dataset. In the context of deep learning, we usually want to learn the entire probability distribution that generated a dataset, whether explicitly as in density estimation or implicitly for tasks like synthesis or denoising. Some other unsupervised learning algorithms perform other roles, like clustering, which consists of dividing the dataset into clusters of similar examples.\n 无监督学习算法(unsupervised learning algorithm) 中, 数据没有标签.无监督学习使我们能够在几乎不知道结果应该是什么样子的情况下解决问题. 我们可以从数据中推导出结构, 而我们不一定知道变量的影响. 我们可以通过基于数据中变量之间的关系对数据进行聚类来推导出这种结构. 对于无监督学习, 没有基于预测结果的反馈.\n Supervised learning algorithms experience a dataset containing features, but each example is also associated with a label or target.\n 监督学习算法(supervised learning algorithm) 中, 我们得到了一个数据集, 并且已经知道我们的正确输出应该是什么样子, 并且知道输入和输出之间存在关系. 监督学习问题分为“回归”和“分类”问题. 在回归问题中, 我们试图预测连续输出中的结果, 这意味着我们试图将输入变量映射到某个连续函数.在分类问题中, 我们试图在离散输出中预测结果. 换句话说, 我们试图输入变量映射到离散类别中.\n Unsupervised learning and supervised learning are not formally defined terms. The lines between them are often blurred. Many machine learning technologies can be used to perform both tasks.\nThough unsupervised learning and supervised learning are not completely formal or distinct concepts, they do help to roughly categorize some of the things we do with machine learning algorithms. Traditionally, people refer to regression, classification and structured output problems as supervised learning. Density estimation in support of other tasks is usually considered unsupervised learning.\nOther variants of the learning paradigm are possible. For example, in semi-supervised learning, some examples include a supervision target but others do not. In multi-instance learning, an entire collection of examples is labeled as containing or not containing an example of a class, but the individual members of the collection are not labeled.\n 半监督学习(semi-supervised learning) 中, 一些样本有监督目标, 但其他样本没有.\n Some machine learning algorithms do not just experience a fixed dataset. For example, reinforcement learning algorithms interact with an environment, so there is a feedback loop between the learning system and its experiences.\n 强化算法(reinforcement learning algorithms) 通过反复试验来实现明确的目标. 它尝试了许多不同的事情, 并根据其行为是帮助还是阻碍其实现目标而受到奖励或惩罚. 这就像在教狗新把戏时给予和扣留零食一样. 强化学习是谷歌 AlphaGo 的基础.\n Most machine learning algorithms simply experience a dataset. A dataset can be described in many ways. In all cases, a dataset is a collection of examples, which are in turn collections of features.\nCapacity, Overfitting and Underfitting The central challenge in machine learning is that we must perform well on new, previously unseen inputs—not just those on which our model was trained. The ability to perform well on previously unobserved inputs is called generalization.\n 机器学习的主要挑战是我们的算法必须能够在先前未观测的新输入上表现良好, 而不只是在训练集上表现良好.在先前未观测到的输入上表现良好的能力被称为 泛化(generalization) .\n Typically, when training a machine learning model, we have access to a training set, we can compute some error measure on the training set called the training error, and we reduce this training error. So far, what we have described is simply an optimization problem. What separates machine learning from optimization is that we want the generalization error, also called the test error, to be low as well. The generalization error is defined as the expected value of the error on a new input. Here the expectation is taken across different possible inputs, drawn from the distribution of inputs we expect the system to encounter in practice.\n 通常情况下, 当我们训练机器学习模型时, 我们可以使用某个训练集, 在训练集上计算一些被称为 训练误差(training error) 的度量误差, 目标是降低训练误差.机器学习和优化不同的地方在于, 我们也希望 泛化误差(generalization error) (也被称为 测试误差(test error) )很低.\n We typically estimate the generalization error of a machine learning model by measuring its performance on a test set of examples that were collected separately from the training set.\nThe train and test data are generated by a probability distribution over datasets called the data generating process. We typically make a set of assumptions known collectively as the i.i.d. assumptions. These assumptions are that the examples in each dataset are independent from each other, and that the train set and test set are identically distributed, drawn from the same probability distribution as each other. This assumption allows us to describe the data generating process with a probability distribution over a single example. The same distribution is then used to generate every train example and every test example. We call that shared underlying distribution the data generating distribution, denoted $p_{data}$. This probabilistic framework and the i.i.d. assumptions allow us to mathematically study the relationship between training error and test error.\nOne immediate connection we can observe between the training and test error is that the expected training error of a randomly selected model is equal to the expected test error of that model. Suppose we have a probability distribution $p(x,y)$ and we sample from it repeatedly to generate the train set and the test set. For some fixed value $w$, the expected training set error is exactly the same as the expected test set error, because both expectations are formed using the same dataset sampling process. The only difference between the two conditions is the name we assign to the dataset we sample.\nOf course, when we use a machine learning algorithm, we do not fix the parameters ahead of time, then sample both datasets. We sample the training set, then use it to choose the parameters to reduce training set error, then sample the test set. Under this process, the expected test error is greater than or equal to the expected value of training error. The factors determining how well a machine learning algorithm will perform are its ability to:\n Make the training error small. Make the gap between training and test error small.  These two factors correspond to the two central challenges in machine learning: underfitting and overfitting. Underfitting occurs when the model is not able to obtain a sufficiently low error value on the training set. Overfitting occurs when the gap between the training error and test error is too large.\n 欠拟合(underfitting) 是指模型不能在训练集上获得足够低的误差. 而 过拟合 (overfitting) 是指训练误差和和测试误差之间的差距太大.\n  We can control whether a model is more likely to overfit or underfit by altering its capacity. Informally, a model’s capacity is its ability to fit a wide variety of functions. Models with low capacity may struggle to fit the training set. Models with high capacity can overfit by memorizing properties of the training set that do not serve them well on the test set.\nOne way to control the capacity of a learning algorithm is by choosing its hypothesis space, the set of functions that the learning algorithm is allowed to select as being the solution. For example, the linear regression algorithm has the set of all linear functions of its input as its hypothesis space. We can generalize linear regression to include polynomials, rather than just linear functions, in its hypothesis space. Doing so increases the model’s capacity.\nWe must remember that while simpler functions are more likely to generalize (to have a small gap between training and test error) we must still choose a sufficiently complex hypothesis to achieve low training error. Typically, training error decreases until it asymptotes to the minimum possible error value as model capacity increases (assuming the error measure has a minimum value). Typically, generalization error has a U-shaped curve as a function of model capacity.\n The No Free Lunch Theorem Learning theory claims that a machine learning algorithm can generalize well from a finite training set of examples. This seems to contradict some basic principles of logic. Inductive reasoning, or inferring general rules from a limited set of examples, is not logically valid. To logically infer a rule describing every member of a set, one must have information about every member of that set.\nIn part, machine learning avoids this problem by offering only probabilistic rules, rather than the entirely certain rules used in purely logical reasoning. Machine learning promises to find rules that are probably correct about most members of the set they concern.\nUnfortunately, even this does not resolve the entire problem. The no free lunch theorem for machine learning (Wolpert, 1996) states that, averaged over all possible data generating distributions, every classification algorithm has the same error rate when classifying previously unobserved points. In other words, in some sense, no machine learning algorithm is universally any better than any other. The most sophisticated algorithm we can conceive of has the same average performance (over all possible tasks) as merely predicting that every point belongs to the same class.\n 机器学习的 没有 免费午餐定理(no free lunch theorem) 表明 (Wolpert, 1996), 在所有可能的数据生成分布上平均之后, 每一个分类算法在未事先观测的点上都有相同的错误率. 换言之, 在某种意义上, 没有一个机器学习算法总是比其他的要好.\n Fortunately, these results hold only when we average over all possible data generating distributions. If we make assumptions about the kinds of probability distributions we encounter in real-world applications, then we can design learning algorithms that perform well on these distributions.\nThis means that the goal of machine learning research is not to seek a universal learning algorithm or the absolute best learning algorithm. Instead, our goal is to understand what kinds of distributions are relevant to the “real world” that an AI agent experiences, and what kinds of machine learning algorithms perform well on data drawn from the kinds of data generating distributions we care about.\nRegularization The no free lunch theorem implies that we must design our machine learning algorithms to perform well on a specific task. We do so by building a set of preferences into the learning algorithm. When these preferences are aligned with the learning problems we ask the algorithm to solve, it performs better.\nWe can regularize a model that learns a function f(x; θ) by adding a penalty called a regularizer to the cost function.\nExpressing preferences for one function over another is a more general way of controlling a model’s capacity than including or excluding members from the hypothesis space. We can think of excluding a function from a hypothesis space as expressing an infinitely strong preference against that function.\nIn weight decay example, we expressed our preference for linear functions defined with smaller weights explicitly, via an extra term in the criterion we minimize. There are many other ways of expressing preferences for different solutions, both implicitly and explicitly. Together, these different approaches are known as regularization. Regularization is any modification we make to a learning algorithm that is intended to reduce its generalization error but not its training error. Regularization is one of the central concerns of the field of machine learning, rivaled in its importance only by optimization.\n 正则化(regularization) 是指我们修改学习算法，使其降低泛化误差而非训练误差。正则化是机器学习领域的中心问题之一，只有优化能够与其重要性相媲。\n The no free lunch theorem has made it clear that there is no best machine learning algorithm, and, in particular, no best form of regularization. Instead we must choose a form of regularization that is well-suited to the particular task we want to solve.\nHyperparameters and Validation Sets Most machine learning algorithms have several settings that we can use to control the behavior of the learning algorithm. These settings are called hyperparame- ters. The values of hyperparameters are not adapted by the learning algorithm itself (though we can design a nested learning procedure where one learning algorithm learns the best hyperparameters for another learning algorithm).\nSometimes a setting is chosen to be a hyperparameter that the learning algorithm does not learn because it is difficult to optimize. More frequently, the setting must be a hyperparameter because it is not appropriate to learn that hyperparameter on the training set. This applies to all hyperparameters that control model capacity. If learned on the training set, such hyperparameters would always choose the maximum possible model capacity, resulting in overfitting. For example, we can always fit the training set better with a higher degree polynomial and a weight decay setting of $\\lambda = 0$ than we could with a lower degree polynomial and a positive weight decay setting.\nTo solve this problem, we need a validation set of examples that the training algorithm does not observe.\nEarlier we discussed how a held-out test set, composed of examples coming from the same distribution as the training set, can be used to estimate the generalization error of a learner, after the learning process has completed. It is important that the test examples are not used in any way to make choices about the model, including its hyperparameters. For this reason, no example from the test set can be used in the validation set. Therefore, we always construct the validation set from the training data. Specifically, we split the training data into two disjoint subsets. One of these subsets is used to learn the parameters. The other subset is our validation set, used to estimate the generalization error during or after training, allowing for the hyperparameters to be updated accordingly. The subset of data used to learn the parameters is still typically called the training set, even though this may be confused with the larger pool of data used for the entire training process. The subset of data used to guide the selection of hyperparameters is called the validation set. Typically, one uses about 80% of the training data for training and 20% for validation. Since the validation set is used to “train” the hyperparameters, the validation set error will underestimate the generalization error, though typically by a smaller amount than the training error. After all hyperparameter optimization is complete, the generalization error may be estimated using the test set.\nCross-Validation Dividing the dataset into a fixed training set and a fixed test set can be problematic if it results in the test set being small. A small test set implies statistical uncertainty around the estimated average test error, making it difficult to claim that algorithm $A$ works better than algorithm $B$ on the given task.\nWhen the dataset has hundreds of thousands of examples or more, this is not a serious issue. When the dataset is too small, are alternative procedures enable one to use all of the examples in the estimation of the mean test error, at the price of increased computational cost. These procedures are based on the idea of repeating the training and testing computation on different randomly chosen subsets or splits of the original dataset. The most common of these is the $k$-fold cross-validation procedure, in which a partition of the dataset is formed by splitting it into $k$ non-overlapping subsets. The test error may then be estimated by taking the average test error across $k$ trials. On trial $i$, the $i$-th subset of the data is used as the test set and the rest of the data is used as the training set.\nEstimators, Bias and Variance The field of statistics gives us many tools that can be used to achieve the machine learning goal of solving a task not only on the training set but also to generalize. Foundational concepts such as parameter estimation, bias and variance are useful to formally characterize notions of generalization, underfitting and overfitting.\nPoint Estimation Point estimation is the attempt to provide the single “best” prediction of some quantity of interest. In general the quantity of interest can be a single parameter or a vector of parameters in some parametric model.\nIn order to distinguish estimates of parameters from their true value, our convention will be to denote a point estimate of a parameter $\\theta$ by $\\hat{\\theta}$.\nLet $\\{x^{(1)},\\cdots,x^{(m)}\\}$ be a set of $m$ independent and identically distributed (i.i.d.) data points. A point estimator or statistic is any function of the data:\n$$ \\hat{\\theta}_{m}=g(x^{(1)},\\cdots,x^{(m)}) \\\\ $$\nThe definition does not require that $g$ return a value that is close to the true $\\theta$ or even that the range of $g$ is the same as the set of allowable values of $\\theta$. This definition of a point estimator is very general and allows the designer of an estimator great flexibility. While almost any function thus qualifies as an estimator, a good estimator is a function whose output is close to the true underlying $\\theta$ that generated the training data.\nFor now, we take the frequentist perspective on statistics. That is, we assume that the true parameter value $\\theta$ is fixed but unknown, while the point estimate $\\hat{\\theta}$ is a function of the data. Since the data is drawn from a random process, any function of the data is random. Therefore $\\hat{\\theta}$ is a random variable.\nPoint estimation can also refer to the estimation of the relationship between input and target variables. We refer to these types of point estimates as function estimators.\nFunction Estimation: As we mentioned above, sometimes we are interested in performing function estimation (or function approximation). Here we are trying to predict a variable $y$ given an input vector $x$. We assume that there is a function $f(x)$ that describes the approximate relationship between $y$ and $x$. For example, we may assume that $y=f(x)+\\epsilon$, where $\\epsilon$ stands for the part of $y$ that is not predictable from $x$. In function estimation, we are interested in approximating $f$ with a model or estimate $\\hat{f}$. Function estimation is really just the same as estimating a parameter $\\theta$; the function estimator $\\hat{f}$ is simply a point estimator in function space.\n 函数估计(Function Estimation): 有时我们会关注函数估计(或函数近似)。这时我们试图从输入向量 $x$ 预测变量 $y$。我们假设有一个函数 $f(x)$ 表示 $y$ 和 $x$ 之间的近似关系。\n Bias The bias of an estimator is defined as:\n$$ bias(\\hat{\\theta}_{m})=E(\\hat{\\theta}_{m})-\\theta \\\\ $$\nwhere the expectation is over the data (seen as samples from a random variable) and $\\theta$ is the true underlying value of $\\theta$ used to define the data generating distribution. An estimator $\\hat{\\theta}_{m}$ is said to be unbiased if $bias(\\hat{\\theta}_{m})=0$, which implies that $E[\\hat{\\theta}_{m}]=\\theta$. An estimator $\\hat{\\theta}_{m}$ is said to be asymptotically unbiased if $\\lim_{m\\to\\infty}bias(\\hat{\\theta}_{m})=0$, which implies that $\\lim_{m\\to\\infty}E[\\hat{\\theta}_{m}]=\\theta$.\n 如果 $bias(\\hat{\\theta}_{m})=0$，那么估计量 $\\hat{\\theta}_{m}$ 被称为是 无偏 (unbiased) ，这意味着 $E[\\hat{\\theta}_{m}]=\\theta$。如果 $\\lim_{m\\to\\infty}bias(\\hat{\\theta}_{m})=0$，那么估计量 $\\hat{\\theta}_{m}$ 被称为是 渐近无偏(asymptotically unbiased) ，这意味着 $\\lim_{m\\to\\infty}E[\\hat{\\theta}_{m}]=\\theta$。\n Variance and Standard Error Another property of the estimator that we might want to consider is how much we expect it to vary as a function of the data sample. Just as we computed the expectation of the estimator to determine its bias, we can compute its variance. The variance of an estimator is simply the variance\n$$ Var(\\hat{\\theta}) \\\\ $$\nwhere the random variable is the training set. Alternately, the square root of the variance is called the standard error, denoted $SE(\\hat{\\theta})$.\nThe variance or the standard error of an estimator provides a measure of how we would expect the estimate we compute from data to vary as we independently resample the dataset from the underlying data generating process. Just as we might like an estimator to exhibit low bias we would also like it to have relatively low variance.\n 估计量的 方差(variance) 或 标准差(standard error) 告诉我们，当独立地从潜在的数据生成过程中重采样数据集时，如何期望估计的变化。正如我们希望估计的偏差较小，我们也希望其方差较小。\n When we compute any statistic using a finite number of samples, our estimate of the true underlying parameter is uncertain, in the sense that we could have obtained other samples from the same distribution and their statistics would have been different. The expected degree of variation in any estimator is a source of error that we want to quantify.\nThe standard error of the mean is given by\n$$ SE(\\hat{\\mu}_{m})=\\sqrt{Var \\left[\\frac{1}{m}\\sum_{i=1}^{m}x^{(i)}\\right]} = \\frac{\\sigma}{\\sqrt{m}} \\\\ $$\nwhere $\\sigma^{2}$ is the true variance of the samples $x^{i}$. The standard error is often estimated by using an estimate of $\\sigma$. Unfortunately, neither the square root of the sample variance nor the square root of the unbiased estimator of the variance provide an unbiased estimate of the standard deviation. Both approaches tend to underestimate the true standard deviation, but are still used in practice. The square root of the unbiased estimator of the variance is less of an underestimate. For large $m$, the approximation is quite reasonable.\nThe standard error of the mean is very useful in machine learning experiments. We often estimate the generalization error by computing the sample mean of the error on the test set. The number of examples in the test set determines the accuracy of this estimate. Taking advantage of the central limit theorem, which tells us that the mean will be approximately distributed with a normal distribution, we can use the standard error to compute the probability that the true expectation falls in any chosen interval. For example, the 95% confidence interval centered on the mean $\\hat{\\mu}_{m}$ is\n$$ (\\hat{\\mu}_{m}-1.96SE(\\hat{\\mu}_{m}),\\hat{\\mu}_{m}+1.96SE(\\hat{\\mu}_{m})) \\\\ $$\nunder the normal distribution with mean $\\mu_{m}$ and variance $SE(\\hat{\\mu}_{m})^{2}$. In machine learning experiments, it is common to say that algorithm $A$ is better than algorithm $B$ if the upper bound of the 95% confidence interval for the error of algorithm $A$ is less than the lower bound of the 95% confidence interval for the error of algorithm $B$.\nTrading off Bias and Variance to Minimize Mean Squared Error Bias and variance measure two different sources of error in an estimator. Bias measures the expected deviation from the true value of the function or parameter. Variance on the other hand, provides a measure of the deviation from the expected estimator value that any particular sampling of the data is likely to cause.\nWhat happens when we are given a choice between two estimators, one with more bias and one with more variance? How do we choose between them?\nThe most common way to negotiate this trade-off is to use cross-validation. Empirically, cross-validation is highly successful on many real-world tasks. Alternatively, we can also compare the mean squared error (MSE) of the estimates:\n$$ \\begin{align*} MSE \u0026= E[(\\hat{\\theta}_{m}-\\theta)^{2}] \\\\ \u0026= Bias(\\hat{\\theta}_{m})^{2} + Var(\\hat{\\theta}_{m}) \\\\ \\end{align*} $$\nThe MSE measures the overall expected deviation—in a squared error sense— between the estimator and the true value of the parameter $\\theta$.\nThe relationship between bias and variance is tightly linked to the machine learning concepts of capacity, underfitting and overfitting. In the case where generalization error is measured by the MSE (where bias and variance are meaningful components of generalization error), increasing capacity tends to increase variance and decrease bias.\n Consistency So far we have discussed the properties of various estimators for a training set of fixed size. Usually, we are also concerned with the behavior of an estimator as the amount of training data grows. In particular, we usually wish that, as the number of data points m in our dataset increases, our point estimates converge to the true value of the corresponding parameters. More formally, we would like that\n$$ \\mathrm{plim}_{m\\to\\infty}\\hat{\\theta}_{m}=\\theta \\\\ $$\nThe symbol $\\mathrm{plim}$ indicates convergence in probability, meaning that for any $\\epsilon 0$, $P(|\\hat{\\theta}_{m}-\\theta| \\epsilon)\\to 0$ as $m \\to \\infty$. The condition described by equation $\\mathrm{plim}_{m\\to\\infty}\\hat{\\theta}_{m}=\\theta$ is known as consistency. It is sometimes referred to as weak consistency, with strong consistency referring to the almost sure convergence of $\\hat{\\theta}$ to $\\theta$. Almost sure convergence of a sequence of random variables $x^{(1)},x^{(2)},\\cdots$ to a value $x$ occurs when $p(\\lim_{m\\to\\infty} x^{(m)} = x) = 1$.\nConsistency ensures that the bias induced by the estimator diminishes as the number of data examples grows. However, the reverse is not true—asymptotic unbiasedness does not imply consistency.\nMaximum Likelihood Estimation We have seen some definitions of common estimators and analyzed their properties. But where did these estimators come from? Rather than guessing that some function might make a good estimator and then analyzing its bias and variance, we would like to have some principle from which we can derive specific functions that are good estimators for different models.\nThe most common such principle is the maximum likelihood principle.\nConsider a set of m examples $\\mathbb{X}=x^{(1)},\\cdots,x^{(m)}$ drawn independently from the true but unknown data generating distribution $p_{data}(x)$.\nLet $p_{model}(x;\\theta)$ be a parametric family of probability distributions over the same space indexed by $\\theta$. In other words, $p_{model}(x;\\theta)$ maps any configuration $x$ to a real number estimating the true probability $p_{data}(x)$.\nThe maximum likelihood estimator for $\\theta$ is then defined as\n$$ \\begin{align*} \\theta_{ML}\u0026=\\arg\\max_{\\theta}p_{model}(\\mathbb{X};\\theta) \\\\ \u0026= \\arg\\max_{\\theta}\\prod_{i=1}^{m}p_{model}(x^{(i)};\\theta) \\\\ \\end{align*} $$\nThis product over many probabilities can be inconvenient for a variety of reasons. For example, it is prone to numerical underflow. To obtain a more convenient but equivalent optimization problem, we observe that taking the logarithm of the likelihood does not change its arg max but does conveniently transform a product into a sum:\n$$ \\theta_{ML}=\\arg\\max_{\\theta}\\sum_{i=1}^{m}\\log p_{model}(x^{(i)};\\theta) \\\\ $$\nBecause the $\\arg\\max$ does not change when we rescale the cost function, we can divide by $m$ to obtain a version of the criterion that is expressed as an expectation with respect to the empirical distribution $\\hat{p}_{data}$ defined by the training data:\n$$ \\theta_{ML}=\\arg\\max_{\\theta}\\mathbb{E}_{x\\sim \\hat{p}_{data}}\\log p_{model}(x;\\theta) \\\\ $$\nConditional Log-Likelihood and Mean Squared Error The maximum likelihood estimator can readily be generalized to the case where our goal is to estimate a conditional probability $P(y|x;\\theta)$ in order to predict $y$ given $x$. This is actually the most common situation because it forms the basis for most supervised learning. If $X$ represents all our inputs and $Y$ all our observed targets, then the conditional maximum likelihood estimator is\n$$ \\theta_{ML}=\\arg\\max_{\\theta}P(Y|X;\\theta) \\\\ $$\nIf the examples are assumed to be i.i.d., then this can be decomposed into\n$$ \\theta_{ML}=\\arg\\max_{\\theta}\\sum_{i=1}^{m}\\log p_{model}(y^{(i)}|x^{(i)};\\theta) \\\\ $$\nProperties of Maximum Likelihood The main appeal of the maximum likelihood estimator is that it can be shown to be the best estimator asymptotically, as the number of examples $m\\to\\infty$, in terms of its rate of convergence as $m$ increases.\nUnder appropriate conditions, the maximum likelihood estimator has the property of consistency, meaning that as the number of training examples approaches infinity, the maximum likelihood estimate of a parameter converges to the true value of the parameter. These conditions are:\n The true distribution $p_{data}$ must lie within the model family $p_{model}(\\cdot;\\theta)$. Otherwise, no estimator can recover $p_{data}$ . The true distribution $p_{data}$ must correspond to exactly one value of $\\theta$. Other- wise, maximum likelihood can recover the correct $p_{data}$ , but will not be able to determine which value of $\\theta$ was used by the data generating processing.  Bayesian Statistics We have discussed frequentist statistics and approaches based on estimating a single value of $\\theta$, then making all predictions thereafter based on that one estimate. Another approach is to consider all possible values of $\\theta$ when making a prediction. The latter is the domain of Bayesian statistics.\nThe frequentist perspective is that the true parameter value $\\theta$ is fixed but unknown, while the point estimate $\\hat{\\theta}$ is a random variable on account of it being a function of the dataset (which is seen as random).\nThe Bayesian perspective on statistics is quite different. The Bayesian uses probability to reflect degrees of certainty of states of knowledge. The dataset is directly observed and so is not random. On the other hand, the true parameter $\\theta$ is unknown or uncertain and thus is represented as a random variable.\n 频率派(frequentist statistics) 的视角是真实参数 $\\theta$ 是未知的定值，而点估计 $\\hat{\\theta}$ 是考虑数据集上函数(可以看作是随机的)的随机变量。 贝叶斯统计(Bayesian statistics) 的视角完全不同。贝叶斯用概率反映知识状态的确定性程度。数据 集能够被直接观测到，因此不是随机的。另一方面，真实参数 $\\theta$ 是未知或不确定的， 因此可以表示成随机变量。\n Before observing the data, we represent our knowledge of $\\theta$ using the prior probability distribution, $p(\\theta)$ (sometimes referred to as simply “the prior”). Generally, the machine learning practitioner selects a prior distribution that is quite broad (i.e. with high entropy) to reflect a high degree of uncertainty in the value of $\\theta$ before observing any data. For example, one might assume a priori that $\\theta$ lies in some finite range or volume, with a uniform distribution. Many priors instead reflect a preference for “simpler” solutions (such as smaller magnitude coefficients, or a function that is closer to being constant).\nNow consider that we have a set of data samples $\\{x^{(1)},\\cdots,x^{(m)}\\}$. We can recover the effect of data on our belief about $\\theta$ by combining the data likelihood $p(x^{(1)},\\cdots,x^{(m)}|\\theta)$ with the prior via Bayes’ rule:\n$$ p(\\theta|x^{(1)},\\cdots,x^{(m)})=\\frac{p(x^{(1)},\\cdots,x^{(m)}|\\theta)p(\\theta)}{p(x^{(1)},\\cdots,x^{(m)})} \\\\ $$\nIn the scenarios where Bayesian estimation is typically used, the prior begins as a relatively uniform or Gaussian distribution with high entropy, and the observation of the data usually causes the posterior to lose entropy and concentrate around a few highly likely values of the parameters.\nRelative to maximum likelihood estimation, Bayesian estimation offers two important differences. First, unlike the maximum likelihood approach that makes predictions using a point estimate of $\\theta$, the Bayesian approach is to make predictions using a full distribution over $\\theta$. For example, after observing $m$ examples, the predicted distribution over the next data sample, $x^{(m+1)}$ , is given by\n$$ p(x^{(m+1)}|x^{(1)},\\cdots,x^{(m)})=\\int p(x^{(m+1)}|\\ \\theta)p(\\theta \\ |x^{(1)},\\cdots,x^{(m)})d\\theta \\\\ $$\nHere each value of $\\theta$ with positive probability density contributes to the prediction of the next example, with the contribution weighted by the posterior density itself. After having observed $\\{x^{(1)},\\cdots,x^{(m)}\\}$, if we are still quite uncertain about the value of $\\theta$, then this uncertainty is incorporated directly into any predictions we might make.\nThe second important difference between the Bayesian approach to estimation and the maximum likelihood approach is due to the contribution of the Bayesian prior distribution. The prior has an influence by shifting probability mass density towards regions of the parameter space that are preferred a priori. In practice, the prior often expresses a preference for models that are simpler or more smooth. Critics of the Bayesian approach identify the prior as a source of subjective human judgment impacting the predictions.\nBayesian methods typically generalize much better when limited training data is available, but typically suffer from high computational cost when the number of training examples is large.\nReference [1] Goodfellow, I., Bengio, Y., \u0026 Courville, A. (2016, Nov 18). Deep Learning. https://www.deeplearningbook.org/contents/ml.html.\n",
  "wordCount" : "6474",
  "inLanguage": "en",
  "datePublished": "2021-06-30T00:00:00Z",
  "dateModified": "2021-06-30T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Followb1ind1y"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://followb1ind1y.github.io/posts/applied_math_and_ml_basics/04_machine_learning_basics_for_ml/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Followb1ind1y",
    "logo": {
      "@type": "ImageObject",
      "url": "https://followb1ind1y.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://followb1ind1y.github.io/" accesskey="h" title="Followb1ind1y (Alt + H)">Followb1ind1y</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://followb1ind1y.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://followb1ind1y.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://followb1ind1y.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://followb1ind1y.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://followb1ind1y.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://followb1ind1y.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      [ML Basics] Machine Learning Basics
    </h1>
    <div class="post-meta">June 30, 2021&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Followb1ind1y
</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <div class="details">Table of Contents</div>
        </summary>
        <div class="inner"><ul>
                <li>
                    <a href="#learning-algorithms" aria-label="Learning Algorithms">Learning Algorithms</a><ul>
                        
                <li>
                    <a href="#the-task-t" aria-label="The Task, $T$">The Task, <code>$T$</code></a></li>
                <li>
                    <a href="#the-performance-measure-p" aria-label="The Performance Measure, $P$">The Performance Measure, <code>$P$</code></a></li>
                <li>
                    <a href="#the-experience-e" aria-label="The Experience, $E$">The Experience, <code>$E$</code></a></li></ul>
                </li>
                <li>
                    <a href="#capacity-overfitting-and-underfitting" aria-label="Capacity, Overfitting and Underfitting">Capacity, Overfitting and Underfitting</a><ul>
                        
                <li>
                    <a href="#the-no-free-lunch-theorem" aria-label="The No Free Lunch Theorem">The No Free Lunch Theorem</a></li>
                <li>
                    <a href="#regularization" aria-label="Regularization">Regularization</a></li></ul>
                </li>
                <li>
                    <a href="#hyperparameters-and-validation-sets" aria-label="Hyperparameters and Validation Sets">Hyperparameters and Validation Sets</a><ul>
                        
                <li>
                    <a href="#cross-validation" aria-label="Cross-Validation">Cross-Validation</a></li></ul>
                </li>
                <li>
                    <a href="#estimators-bias-and-variance" aria-label="Estimators, Bias and Variance">Estimators, Bias and Variance</a><ul>
                        
                <li>
                    <a href="#point-estimation" aria-label="Point Estimation">Point Estimation</a></li>
                <li>
                    <a href="#bias" aria-label="Bias">Bias</a></li>
                <li>
                    <a href="#variance-and-standard-error" aria-label="Variance and Standard Error">Variance and Standard Error</a></li>
                <li>
                    <a href="#trading-off-bias-and-variance-to-minimize-mean-squared-error" aria-label="Trading off Bias and Variance to Minimize Mean Squared Error">Trading off Bias and Variance to Minimize Mean Squared Error</a></li>
                <li>
                    <a href="#consistency" aria-label="Consistency">Consistency</a></li></ul>
                </li>
                <li>
                    <a href="#maximum-likelihood-estimation" aria-label="Maximum Likelihood Estimation">Maximum Likelihood Estimation</a><ul>
                        
                <li>
                    <a href="#conditional-log-likelihood-and-mean-squared-error" aria-label="Conditional Log-Likelihood and Mean Squared Error">Conditional Log-Likelihood and Mean Squared Error</a></li>
                <li>
                    <a href="#properties-of-maximum-likelihood" aria-label="Properties of Maximum Likelihood">Properties of Maximum Likelihood</a></li></ul>
                </li>
                <li>
                    <a href="#bayesian-statistics" aria-label="Bayesian Statistics">Bayesian Statistics</a></li>
                <li>
                    <a href="#reference" aria-label="Reference">Reference</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="learning-algorithms">Learning Algorithms<a hidden class="anchor" aria-hidden="true" href="#learning-algorithms">#</a></h2>
<p>A machine learning algorithm is an algorithm that is able to learn from data. But what do we mean by learning? Mitchell (1997) provides the definition &ldquo;A computer program is said to learn from experience <code>$E$</code> with respect to some class of tasks <code>$T$</code> and performance measure <code>$P$</code>, if its performance at tasks in <code>$T$</code>, as measured by <code>$P$</code>, improves with experience <code>$E$</code>.&rdquo;</p>
<h3 id="the-task-t">The Task, <code>$T$</code><a hidden class="anchor" aria-hidden="true" href="#the-task-t">#</a></h3>
<p>Machine learning allows us to tackle tasks that are too difficult to solve with fixed programs written and designed by human beings. From a scientific and philosophical point of view, machine learning is interesting because developing our understanding of machine learning entails developing our understanding of the principles that underlie intelligence.</p>
<p>In this relatively formal definition of the word &ldquo;task,&rdquo; the process of learning itself is not the task. Learning is our means of attaining the ability to perform the task.</p>
<p>Machine learning tasks are usually described in terms of how the machine learning system should process an <strong>example</strong>. An example is a collection of <strong>features</strong> that have been quantitatively measured from some object or event that we want the machine learning system to process. We typically represent an example as a vector <code>$x \in \mathbb{R}$</code> where each entry <code>$x_{i}$</code> of the vector is another feature. For example, the features of an image are usually the values of the pixels in the image.</p>
<blockquote>
<p>通常机器学习任务定义为机器学习系统应该如何处理 <strong>样本(example)</strong>. 样本是指我们从某些希望机器学习系统处理的对象或事件中收集到的已经量化的 <strong>特征 (feature)</strong> 的集合.</p>
</blockquote>
<p>Many kinds of tasks can be solved with machine learning. Some of the most common machine learning tasks include the following:</p>
<ul>
<li><strong>Classification</strong>: In this type of task, the computer program is asked to specify which of <code>$k$</code> categories some input belongs to. To solve this task, the learning algorithm is usually asked to produce a function <code>$f: \mathbb{R}^{n} \to \{1, \cdots,k \}$</code>. When <code>$y=f(x)$</code>, the model assigns an input described by vector <code>$x$</code> to a category identified by numeric code <code>$y$</code>. There are other variants of the classification task, for example, where <code>$f$</code> outputs a probability distribution over classes. An example of a classification task is <strong>object recognition</strong>, where the input is an image (usually described as a set of pixel brightness values), and the output is a numeric code identifying the object in the image. Object recognition is the same basic technology that allows computers to recognize faces (Taigman et al., 2014), which can be used to automatically tag people in photo collections and allow computers to interact more naturally with their users.</li>
</ul>
<blockquote>
<p><strong>分类</strong>: 在这类任务中, 计算机程序需要指定某些输入属于 <code>$k$</code> 类中的哪一类. 为了完成这个任务, 学习算法通常会返回一个函数 <code>$f: \mathbb{R}^{n} \to \{1, \cdots,k \}$</code>.当 <code>$y=f(x)$</code> 时, 模型将向量 <code>$x$</code> 所代表的输入分类到数字码 <code>$y$</code> 所代表的类别.还有一些其他的分类问题, 例如, <code>$f$</code> 输出的是不同类别的概率分布. 代表示例有： 人脸识别.</p>
</blockquote>
<ul>
<li><strong>Classification with missing inputs</strong>: Classification becomes more challenging if the computer program is not guaranteed that every measurement in its input vector will always be provided. In order to solve the classification task, the learning algorithm only has to define a <em>single</em> function mapping from a vector input to a categorical output. When some of the inputs may be missing, rather than providing a single classification function, the learning algorithm must learn a <em>set</em> of functions. Each function corresponds to classifying <code>$x$</code> with a different subset of its inputs missing. This kind of situation arises frequently in medical diagnosis, because many kinds of medical tests are expensive or invasive. One way to efficiently define such a large set of functions is to learn a probability distribution over all of the relevant variables, then solve the classification task by marginalizing out the missing variables. With <code>$n$</code> input variables, we can now obtain all <code>$2^{n}$</code> different classification functions needed for each possible set of missing inputs, but we only need to learn a single function describing the joint probability distribution.</li>
</ul>
<blockquote>
<p><strong>输入缺失分类</strong>: 当输入向量的每个度量不被保证的时候, 分类问题将会变得更有挑战性. 为了解决分类任务, 学习算法只需要定义一个从输入向量映射到输出类别的函数. 当一些输入可能丢失时, 学习算法必须学习一组函数, 而不是单个分类函数. 每个函数对应着分类具有不同缺失输入子集的 <code>$x$</code>. 这种情况在 医疗诊断中经常出现, 因为很多类型的医学测试是昂贵的, 对身体有害的.</p>
</blockquote>
<ul>
<li><strong>Regression</strong>: In this type of task, the computer program is asked to predict a numerical value given some input. To solve this task, the learning algorithm is asked to output a function <code>$f:\mathbb{R}^{n}\to\mathbb{R}$</code>. This type of task is similar to classification, except that the format of output is different. An example of a regression task is the prediction of the expected claim amount that an insured person will make (used to set insurance premiums), or the prediction of future prices of securities. These kinds of predictions are also used for algorithmic trading.</li>
</ul>
<blockquote>
<p><strong>回归</strong>: 在这类任务中, 计算机程序需要对给定输入预测数值.为了解决这个任务, 学习算法需要输出函数 <code>$f:\mathbb{R}^{n}\to\mathbb{R}$</code>.除了返回结果的形式不一样外, 这类问题和分类问题是很像的. 代表示例有：预测证券未来的价格.</p>
</blockquote>
<ul>
<li><strong>Transcription</strong>: In this type of task, the machine learning system is asked to observe a relatively unstructured representation of some kind of data and transcribe it into discrete, textual form. For example, in optical character recognition, the computer program is shown a photograph containing an image of text and is asked to return this text in the form of a sequence of characters (e.g., in ASCII or Unicode format). Another example is speech recognition, where the computer program is provided an audio waveform and emits a sequence of characters or word ID codes describing the words that were spoken in the audio recording. Deep learning is a crucial component of modern speech recognition systems used at major companies.</li>
</ul>
<blockquote>
<p><strong>转录</strong>: 这类任务中, 机器学习系统观测一些相对非结构化表示的数据, 并转录信息为离散的文本形式.代表示例有：光学字符识别要求计算机程序根据文本图片返回文字序列、语音识别.</p>
</blockquote>
<ul>
<li><strong>Machine translation</strong>: In a machine translation task, the input already consists of a sequence of symbols in some language, and the computer program must convert this into a sequence of symbols in another language. This is commonly applied to natural languages, such as translating from English to French.</li>
</ul>
<blockquote>
<p><strong>机器翻译</strong>: 在机器翻译任务中, 输入是一种语言的符号序列, 计算机程序必须将其转化成另一种语言的符号序列. 代表示例有：英语翻译成法语.</p>
</blockquote>
<ul>
<li><strong>Structured output</strong>: Structured output tasks involve any task where the output is a vector (or other data structure containing multiple values) with important relationships between the different elements. This is a broad category, and subsumes the transcription and translation tasks described above, but also many other tasks. One example is parsing—mapping a natural language sentence into a tree that describes its grammatical structure and tagging nodes of the trees as being verbs, nouns, or adverbs, and so on. Another example is pixel-wise segmentation of images, where the computer program assigns every pixel in an image to a specific category.</li>
</ul>
<blockquote>
<p><strong>结构化输出</strong>: 结构化输出任务的输出是向量或者其他包含多个值的数据结构, 并且构成输出的这些不同元素间具有重要关系.这是一个很大的范畴, 包括上述转录任务和翻译任务在内的很多其他任务. 代表示例有：语法分析、图像的像素级分割, 将每一个像素分配到特定类别.</p>
</blockquote>
<ul>
<li><strong>Anomaly detection</strong>: In this type of task, the computer program sifts through a set of events or objects, and flags some of them as being unusual or atypical. An example of an anomaly detection task is credit card fraud detection. By modeling your purchasing habits, a credit card company can detect misuse of your cards. If a thief steals your credit card or credit card information, the thief’s purchases will often come from a different probability distribution over purchase types than your own. The credit card company can prevent fraud by placing a hold on an account as soon as that card has been used for an uncharacteristic purchase.</li>
</ul>
<blockquote>
<p><strong>异常检测</strong>: 在这类任务中, 计算机程序在一组事件或对象中筛选, 并标记不正常或非典型的个体. 异常检测任务的一个示例是信用卡欺诈检测.</p>
</blockquote>
<ul>
<li><strong>Synthesis and sampling</strong>: In this type of task, the machine learning algorithm is asked to generate new examples that are similar to those in the training data. Synthesis and sampling via machine learning can be useful for media applications where it can be expensive or boring for an artist to generate large volumes of content by hand. For example, video games can automatically generate textures for large objects or landscapes, rather than requiring an artist to manually label each pixel.</li>
</ul>
<blockquote>
<p><strong>合成和采样</strong>: 在这类任务中, 机器学习程序生成一些和训练数据相似的新样本. 通过机器学习, 合成和采样可能在媒体应用中非常有用, 可以避免艺术家大量昂贵或者乏味费时的手动工作. 例如, 视频游戏可以自动生成大型物体或风景的纹理, 而不是让艺术家手动标记每个像素.</p>
</blockquote>
<ul>
<li><strong>Imputation of missing values</strong>: In this type of task, the machine learning algorithm is given a new example <code>$x \in \mathbb{R}^{n}$</code>, but with some entries <code>$x_{i}$</code> of <code>$x$</code> missing. The algorithm must provide a prediction of the values of the missing entries.</li>
</ul>
<blockquote>
<p><strong>缺失值填补</strong>: 在这类任务中, 机器学习算法给定一个新样本 <code>$x \in \mathbb{R}^{n}$</code>, <code>$x$</code> 中某些元素 <code>$x_{i}$</code> 缺失.算法必须填补这些缺失值.</p>
</blockquote>
<ul>
<li><strong>Denoising</strong>: In this type of task, the machine learning algorithm is given in input a <em>corrupted example</em> <code>$\tilde{x} \in \mathbb{R}^{n}$</code> obtained by an unknown corruption process from a <em>clean example</em> <code>$x\in \mathbb{R}^{n}$</code>. The learner must predict the clean example <code>$x$</code> from its corrupted version <code>$\tilde{x}$</code>, or more generally predict the conditional probability distribution <code>$p(x \ | \ \tilde{x})$</code>.</li>
</ul>
<blockquote>
<p><strong>去噪</strong>: 在这类任务中, 机器学习算法的输入是, 干净样本 <code>$x\in \mathbb{R}^{n}$</code> 经过未知损坏过程后得到的损坏样本 <code>$\tilde{x} \in \mathbb{R}^{n}$</code>.算法根据损坏后的样本 <code>$\tilde{x}$</code> 预测干净的样本 <code>$x$</code>, 或者更一般地预测条件概率分布 <code>$p(x \ | \ \tilde{x})$</code>.</p>
</blockquote>
<p>Of course, many other tasks and types of tasks are possible. The types of tasks we list here are intended only to provide examples of what machine learning can do, not to define a rigid taxonomy of tasks.</p>
<h3 id="the-performance-measure-p">The Performance Measure, <code>$P$</code><a hidden class="anchor" aria-hidden="true" href="#the-performance-measure-p">#</a></h3>
<p>In order to evaluate the abilities of a machine learning algorithm, we must design a quantitative measure of its performance. Usually this performance measure <code>$P$</code> is specific to the task <code>$T$</code> being carried out by the system.</p>
<p>For tasks such as classification, classification with missing inputs, and transcription, we often measure the <strong>accuracy</strong> of the model. Accuracy is just the proportion of examples for which the model produces the correct output. We can also obtain equivalent information by measuring the <strong>error rate</strong>, the proportion of examples for which the model produces an incorrect output. We often refer to the error rate as the expected 0-1 loss. The 0-1 loss on a particular example is 0 if it is correctly classified and 1 if it is not. For tasks such as density estimation, it does not make sense to measure accuracy, error rate, or any other kind of 0-1 loss. Instead, we must use a different performance metric that gives the model a continuous-valued score for each example. The most common approach is to report the average log-probability the model assigns to some examples.</p>
<blockquote>
<p>对于诸如分类、缺失输入分类和转录任务, 我们通常度量模型的 <strong>准确率(accuracy)</strong>.准确率是指该模型输出正确结果的样本比率. 我们也可以通过 <strong>错误率(error rate)</strong> 得到相同的信息. 错误率是指该模型输出错误结果的样本比率.</p>
</blockquote>
<p>Usually we are interested in how well the machine learning algorithm performs on data that it has not seen before, since this determines how well it will work when deployed in the real world. We therefore evaluate these performance measures using a <strong>test set</strong> of data that is separate from the data used for training the machine learning system.</p>
<p>The choice of performance measure may seem straightforward and objective, but it is often difficult to choose a performance measure that corresponds well to the desired behavior of the system.</p>
<h3 id="the-experience-e">The Experience, <code>$E$</code><a hidden class="anchor" aria-hidden="true" href="#the-experience-e">#</a></h3>
<p>Machine learning algorithms can be broadly categorized as <strong>unsupervised</strong> or <strong>supervised</strong> by what kind of experience they are allowed to have during the learning process.</p>
<p>Most of the learning algorithms can be understood as being allowed to experience an entire <strong>dataset</strong>. A dataset is a collection of many examples. Sometimes we will also call examples <strong>data points</strong>.</p>
<p><strong>Unsupervised learning algorithms</strong> experience a dataset containing many features, then learn useful properties of the structure of this dataset. In the context of deep learning, we usually want to learn the entire probability distribution that generated a dataset, whether explicitly as in density estimation or implicitly for tasks like synthesis or denoising. Some other unsupervised learning algorithms perform other roles, like clustering, which consists of dividing the dataset into clusters of similar examples.</p>
<blockquote>
<p><strong>无监督学习算法(unsupervised learning algorithm)</strong> 中, 数据没有标签.无监督学习使我们能够在几乎不知道结果应该是什么样子的情况下解决问题. 我们可以从数据中推导出结构, 而我们不一定知道变量的影响. 我们可以通过基于数据中变量之间的关系对数据进行聚类来推导出这种结构. 对于无监督学习, 没有基于预测结果的反馈.</p>
</blockquote>
<p><strong>Supervised learning algorithms</strong> experience a dataset containing features, but each example is also associated with a <strong>label</strong> or <strong>target</strong>.</p>
<blockquote>
<p><strong>监督学习算法(supervised learning algorithm)</strong> 中, 我们得到了一个数据集, 并且已经知道我们的正确输出应该是什么样子, 并且知道输入和输出之间存在关系.
监督学习问题分为“回归”和“分类”问题. 在回归问题中, 我们试图预测连续输出中的结果, 这意味着我们试图将输入变量映射到某个连续函数.在分类问题中, 我们试图在离散输出中预测结果. 换句话说, 我们试图输入变量映射到离散类别中.</p>
</blockquote>
<p>Unsupervised learning and supervised learning are not formally defined terms. The lines between them are often blurred. Many machine learning technologies can be used to perform both tasks.</p>
<p>Though unsupervised learning and supervised learning are not completely formal or distinct concepts, they do help to roughly categorize some of the things we do with machine learning algorithms. Traditionally, people refer to regression, classification and structured output problems as supervised learning. Density estimation in support of other tasks is usually considered unsupervised learning.</p>
<p>Other variants of the learning paradigm are possible. For example, in <strong>semi-supervised learning</strong>, some examples include a supervision target but others do not. In multi-instance learning, an entire collection of examples is labeled as containing or not containing an example of a class, but the individual members of the collection are not labeled.</p>
<blockquote>
<p><strong>半监督学习(semi-supervised learning)</strong> 中, 一些样本有监督目标, 但其他样本没有.</p>
</blockquote>
<p>Some machine learning algorithms do not just experience a fixed dataset. For example, <strong>reinforcement learning algorithms</strong> interact with an environment, so there is a feedback loop between the learning system and its experiences.</p>
<blockquote>
<p><strong>强化算法(reinforcement learning algorithms)</strong> 通过反复试验来实现明确的目标. 它尝试了许多不同的事情, 并根据其行为是帮助还是阻碍其实现目标而受到奖励或惩罚. 这就像在教狗新把戏时给予和扣留零食一样. 强化学习是谷歌 AlphaGo 的基础.</p>
</blockquote>
<p>Most machine learning algorithms simply experience a dataset. A dataset can be described in many ways. In all cases, a dataset is a collection of examples, which are in turn collections of features.</p>
<h2 id="capacity-overfitting-and-underfitting">Capacity, Overfitting and Underfitting<a hidden class="anchor" aria-hidden="true" href="#capacity-overfitting-and-underfitting">#</a></h2>
<p>The central challenge in machine learning is that we must perform well on new, previously unseen inputs—not just those on which our model was trained. The ability to perform well on previously unobserved inputs is called <strong>generalization</strong>.</p>
<blockquote>
<p>机器学习的主要挑战是我们的算法必须能够在先前未观测的新输入上表现良好, 而不只是在训练集上表现良好.在先前未观测到的输入上表现良好的能力被称为 <strong>泛化(generalization)</strong> .</p>
</blockquote>
<p>Typically, when training a machine learning model, we have access to a training set, we can compute some error measure on the training set called the <strong>training error</strong>, and we reduce this training error. So far, what we have described is simply an optimization problem. What separates machine learning from optimization is that we want the <strong>generalization error</strong>, also called the <strong>test error</strong>, to be low as well. The generalization error is defined as the expected value of the error on a new input. Here the expectation is taken across different possible inputs, drawn from the distribution of inputs we expect the system to encounter in practice.</p>
<blockquote>
<p>通常情况下, 当我们训练机器学习模型时, 我们可以使用某个训练集, 在训练集上计算一些被称为 <strong>训练误差(training error)</strong> 的度量误差, 目标是降低训练误差.机器学习和优化不同的地方在于, 我们也希望 <strong>泛化误差(generalization error)</strong> (也被称为 <strong>测试误差(test error)</strong> )很低.</p>
</blockquote>
<p>We typically estimate the generalization error of a machine learning model by measuring its performance on a <strong>test set</strong> of examples that were collected separately from the training set.</p>
<p>The train and test data are generated by a probability distribution over datasets called the <strong>data generating process</strong>. We typically make a set of assumptions known collectively as the <strong>i.i.d. assumptions</strong>. These assumptions are that the examples in each dataset are <strong>independent</strong> from each other, and that the train set and test set are <strong>identically distributed</strong>, drawn from the same probability distribution as each other. This assumption allows us to describe the data generating process with a probability distribution over a single example. The same distribution is then used to generate every train example and every test example. We call that shared underlying distribution the <strong>data generating distribution</strong>, denoted <code>$p_{data}$</code>. This probabilistic framework and the i.i.d. assumptions allow us to mathematically study the relationship between training error and test error.</p>
<p>One immediate connection we can observe between the training and test error is that the expected training error of a randomly selected model is equal to the expected test error of that model. Suppose we have a probability distribution <code>$p(x,y)$</code> and we sample from it repeatedly to generate the train set and the test set. For some fixed value <code>$w$</code>, the expected training set error is exactly the same as the expected test set error, because both expectations are formed using the same dataset sampling process. The only difference between the two conditions is the name we assign to the dataset we sample.</p>
<p>Of course, when we use a machine learning algorithm, we do not fix the parameters ahead of time, then sample both datasets. We sample the training set, then use it to choose the parameters to reduce training set error, then sample the test set. Under this process, the expected test error is greater than or equal to the expected value of training error. The factors determining how well a machine learning algorithm will perform are its ability to:</p>
<ol>
<li>Make the training error small.</li>
<li>Make the gap between training and test error small.</li>
</ol>
<p>These two factors correspond to the two central challenges in machine learning: <strong>underfitting</strong> and <strong>overfitting</strong>. Underfitting occurs when the model is not able to obtain a sufficiently low error value on the training set. Overfitting occurs when the gap between the training error and test error is too large.</p>
<blockquote>
<p><strong>欠拟合(underfitting)</strong> 是指模型不能在训练集上获得足够低的误差. 而 <strong>过拟合 (overfitting)</strong> 是指训练误差和和测试误差之间的差距太大.</p>
</blockquote>
<div align="center">
  <img src="/img_ML_Basics/ML_Basics_04_Underfitting_Overfitting.PNG" width=500px/>
</div>
<br>
<p>We can control whether a model is more likely to overfit or underfit by altering its <strong>capacity</strong>. Informally, a model’s capacity is its ability to fit a wide variety of functions. Models with low capacity may struggle to fit the training set. Models with high capacity can overfit by memorizing properties of the training set that do not serve them well on the test set.</p>
<p>One way to control the capacity of a learning algorithm is by choosing its <strong>hypothesis space</strong>, the set of functions that the learning algorithm is allowed to select as being the solution. For example, the linear regression algorithm has the set of all linear functions of its input as its hypothesis space. We can generalize linear regression to include polynomials, rather than just linear functions, in its hypothesis space. Doing so increases the model’s capacity.</p>
<p>We must remember that while simpler functions are more likely to generalize (to have a small gap between training and test error) we must still choose a sufficiently complex hypothesis to achieve low training error. Typically, training error decreases until it asymptotes to the minimum possible error value as model capacity increases (assuming the error measure has a minimum value). Typically, generalization error has a U-shaped curve as a function of model capacity.</p>
<div align="center">
  <img src="/img_ML_Basics/ML_Basics_04_Relationship_between_Capacity_Error.PNG" width=600px/>
</div>
<br>
<h3 id="the-no-free-lunch-theorem">The No Free Lunch Theorem<a hidden class="anchor" aria-hidden="true" href="#the-no-free-lunch-theorem">#</a></h3>
<p>Learning theory claims that a machine learning algorithm can generalize well from a finite training set of examples. This seems to contradict some basic principles of logic. Inductive reasoning, or inferring general rules from a limited set of examples, is not logically valid. To logically infer a rule describing every member of a set, one must have information about every member of that set.</p>
<p>In part, machine learning avoids this problem by offering only probabilistic rules, rather than the entirely certain rules used in purely logical reasoning. Machine learning promises to find rules that are probably correct about most members of the set they concern.</p>
<p>Unfortunately, even this does not resolve the entire problem. The <strong>no free lunch theorem</strong> for machine learning (Wolpert, 1996) states that, averaged over all possible data generating distributions, every classification algorithm has the same error rate when classifying previously unobserved points. In other words, in some sense, no machine learning algorithm is universally any better than any other. The most sophisticated algorithm we can conceive of has the same average performance (over all possible tasks) as merely predicting that every point belongs to the same class.</p>
<blockquote>
<p>机器学习的 没有 <strong>免费午餐定理(no free lunch theorem)</strong> 表明 (Wolpert, 1996), 在所有可能的数据生成分布上平均之后, 每一个分类算法在未事先观测的点上都有相同的错误率. 换言之, 在某种意义上, 没有一个机器学习算法总是比其他的要好.</p>
</blockquote>
<p>Fortunately, these results hold only when we average over all possible data generating distributions. If we make assumptions about the kinds of probability distributions we encounter in real-world applications, then we can design learning algorithms that perform well on these distributions.</p>
<p>This means that the goal of machine learning research is not to seek a universal learning algorithm or the absolute best learning algorithm. Instead, our goal is to understand what kinds of distributions are relevant to the &ldquo;real world&rdquo; that an AI agent experiences, and what kinds of machine learning algorithms perform well on data drawn from the kinds of data generating distributions we care about.</p>
<h3 id="regularization">Regularization<a hidden class="anchor" aria-hidden="true" href="#regularization">#</a></h3>
<p>The no free lunch theorem implies that we must design our machine learning algorithms to perform well on a specific task. We do so by building a set of preferences into the learning algorithm. When these preferences are aligned with the learning problems we ask the algorithm to solve, it performs better.</p>
<p>We can regularize a model that learns a function f(x; θ) by adding a penalty called a <strong>regularizer</strong> to the cost function.</p>
<p>Expressing preferences for one function over another is a more general way of controlling a model’s capacity than including or excluding members from the hypothesis space. We can think of excluding a function from a hypothesis space as expressing an infinitely strong preference against that function.</p>
<p>In weight decay example, we expressed our preference for linear functions defined with smaller weights explicitly, via an extra term in the criterion we minimize. There are many other ways of expressing preferences for different solutions, both implicitly and explicitly. Together, these different approaches are known as <strong>regularization</strong>. <em>Regularization is any modification we make to a learning algorithm that is intended to reduce its generalization error but not its training error</em>. Regularization is one of the central concerns of the field of machine learning, rivaled in its importance only by optimization.</p>
<blockquote>
<p><strong>正则化(regularization)</strong> 是指我们修改学习算法，使其降低泛化误差而非训练误差。正则化是机器学习领域的中心问题之一，只有优化能够与其重要性相媲。</p>
</blockquote>
<p>The no free lunch theorem has made it clear that there is no best machine learning algorithm, and, in particular, no best form of regularization. Instead we must choose a form of regularization that is well-suited to the particular task we want to solve.</p>
<h2 id="hyperparameters-and-validation-sets">Hyperparameters and Validation Sets<a hidden class="anchor" aria-hidden="true" href="#hyperparameters-and-validation-sets">#</a></h2>
<p>Most machine learning algorithms have several settings that we can use to control the behavior of the learning algorithm. These settings are called hyperparame- ters. The values of hyperparameters are not adapted by the learning algorithm itself (though we can design a nested learning procedure where one learning algorithm learns the best hyperparameters for another learning algorithm).</p>
<p>Sometimes a setting is chosen to be a hyperparameter that the learning algorithm does not learn because it is difficult to optimize. More frequently, the setting must be a hyperparameter because it is not appropriate to learn that hyperparameter on the training set. This applies to all hyperparameters that control model capacity. If learned on the training set, such hyperparameters would always choose the maximum possible model capacity, resulting in overfitting. For example, we can always fit the training set better with a higher degree polynomial and a weight decay setting of <code>$\lambda = 0$</code> than we could with a lower degree polynomial and a positive weight decay setting.</p>
<p>To solve this problem, we need a <strong>validation set</strong> of examples that the training algorithm does not observe.</p>
<p>Earlier we discussed how a held-out test set, composed of examples coming from the same distribution as the training set, can be used to estimate the generalization error of a learner, after the learning process has completed. It is important that the test examples are not used in any way to make choices about the model, including its hyperparameters. For this reason, no example from the test set can be used in the validation set. Therefore, we always construct the validation set from the training data. Specifically, we split the training data into two disjoint subsets. One of these subsets is used to learn the parameters. The other subset is our validation set, used to estimate the generalization error during or after training, allowing for the hyperparameters to be updated accordingly. The subset of data used to learn the parameters is still typically called the training set, even though this may be confused with the larger pool of data used for the entire training process. The subset of data used to guide the selection of hyperparameters is called the validation set. Typically, one uses about 80% of the training data for training and 20% for validation. Since the validation set is used to &ldquo;train&rdquo; the hyperparameters, the validation set error will underestimate the generalization error, though typically by a smaller amount than the training error. After all hyperparameter optimization is complete, the generalization error may be estimated using the test set.</p>
<h3 id="cross-validation">Cross-Validation<a hidden class="anchor" aria-hidden="true" href="#cross-validation">#</a></h3>
<p>Dividing the dataset into a fixed training set and a fixed test set can be problematic if it results in the test set being small. A small test set implies statistical uncertainty around the estimated average test error, making it difficult to claim that algorithm <code>$A$</code> works better than algorithm <code>$B$</code> on the given task.</p>
<p>When the dataset has hundreds of thousands of examples or more, this is not a serious issue. When the dataset is too small, are alternative procedures enable one to use all of the examples in the estimation of the mean test error, at the price of increased computational cost. These procedures are based on the idea of repeating the training and testing computation on different randomly chosen subsets or splits of the original dataset. The most common of these is the <code>$k$</code>-fold cross-validation procedure, in which a partition of the dataset is formed by splitting it into <code>$k$</code> non-overlapping subsets. The test error may then be estimated by taking the average test error across <code>$k$</code> trials. On trial <code>$i$</code>, the <code>$i$</code>-th subset of the data is used as the test set and the rest of the data is used as the training set.</p>
<h2 id="estimators-bias-and-variance">Estimators, Bias and Variance<a hidden class="anchor" aria-hidden="true" href="#estimators-bias-and-variance">#</a></h2>
<p>The field of statistics gives us many tools that can be used to achieve the machine learning goal of solving a task not only on the training set but also to generalize. Foundational concepts such as parameter estimation, bias and variance are useful to formally characterize notions of generalization, underfitting and overfitting.</p>
<h3 id="point-estimation">Point Estimation<a hidden class="anchor" aria-hidden="true" href="#point-estimation">#</a></h3>
<p>Point estimation is the attempt to provide the single “best” prediction of some quantity of interest. In general the quantity of interest can be a single parameter or a vector of parameters in some parametric model.</p>
<p>In order to distinguish estimates of parameters from their true value, our convention will be to denote a point estimate of a parameter <code>$\theta$</code> by <code>$\hat{\theta}$</code>.</p>
<p>Let <code>$\{x^{(1)},\cdots,x^{(m)}\}$</code> be a set of <code>$m$</code> independent and identically distributed (i.i.d.) data points. A <strong>point estimator</strong> or <strong>statistic</strong> is any function of the data:</p>
<p><code>$$ \hat{\theta}_{m}=g(x^{(1)},\cdots,x^{(m)}) \\ $$</code></p>
<p>The definition does not require that <code>$g$</code> return a value that is close to the true <code>$\theta$</code> or even that the range of <code>$g$</code> is the same as the set of allowable values of <code>$\theta$</code>. This definition of a point estimator is very general and allows the designer of an estimator great flexibility. While almost any function thus qualifies as an estimator, a good estimator is a function whose output is close to the true underlying <code>$\theta$</code> that generated the training data.</p>
<p>For now, we take the frequentist perspective on statistics. That is, we assume that the true parameter value <code>$\theta$</code> is fixed but unknown, while the point estimate <code>$\hat{\theta}$</code> is a function of the data. Since the data is drawn from a random process, any function of the data is random. Therefore <code>$\hat{\theta}$</code> is a random variable.</p>
<p>Point estimation can also refer to the estimation of the relationship between input and target variables. We refer to these types of point estimates as function estimators.</p>
<p><strong>Function Estimation</strong>: As we mentioned above, sometimes we are interested in performing function estimation (or function approximation). Here we are trying to
predict a variable <code>$y$</code> given an input vector <code>$x$</code>. We assume that there is a function <code>$f(x)$</code> that describes the approximate relationship between <code>$y$</code> and <code>$x$</code>. For example, we may assume that <code>$y=f(x)+\epsilon$</code>, where <code>$\epsilon$</code> stands for the part of <code>$y$</code> that is not predictable from <code>$x$</code>. In function estimation, we are interested in approximating <code>$f$</code> with a model or estimate <code>$\hat{f}$</code>. Function estimation is really just the same as estimating a parameter <code>$\theta$</code>; the function estimator <code>$\hat{f}$</code> is simply a point estimator in function space.</p>
<blockquote>
<p><strong>函数估计(Function Estimation)</strong>: 有时我们会关注函数估计(或函数近似)。这时我们试图从输入向量 <code>$x$</code> 预测变量 <code>$y$</code>。我们假设有一个函数 <code>$f(x)$</code> 表示 <code>$y$</code> 和 <code>$x$</code> 之间的近似关系。</p>
</blockquote>
<h3 id="bias">Bias<a hidden class="anchor" aria-hidden="true" href="#bias">#</a></h3>
<p>The bias of an estimator is defined as:</p>
<p><code>$$ bias(\hat{\theta}_{m})=E(\hat{\theta}_{m})-\theta \\ $$</code></p>
<p>where the expectation is over the data (seen as samples from a random variable) and <code>$\theta$</code> is the true underlying value of <code>$\theta$</code> used to define the data generating distribution. An estimator <code>$\hat{\theta}_{m}$</code> is said to be <strong>unbiased</strong> if <code>$bias(\hat{\theta}_{m})=0$</code>, which implies that <code>$E[\hat{\theta}_{m}]=\theta$</code>. An estimator <code>$\hat{\theta}_{m}$</code> is said to be <strong>asymptotically unbiased</strong> if <code>$\lim_{m\to\infty}bias(\hat{\theta}_{m})=0$</code>, which implies that <code>$\lim_{m\to\infty}E[\hat{\theta}_{m}]=\theta$</code>.</p>
<blockquote>
<p>如果 <code>$bias(\hat{\theta}_{m})=0$</code>，那么估计量 <code>$\hat{\theta}_{m}$</code> 被称为是 <strong>无偏 (unbiased)</strong> ，这意味着 <code>$E[\hat{\theta}_{m}]=\theta$</code>。如果 <code>$\lim_{m\to\infty}bias(\hat{\theta}_{m})=0$</code>，那么估计量 <code>$\hat{\theta}_{m}$</code> 被称为是 <strong>渐近无偏(asymptotically unbiased)</strong> ，这意味着 <code>$\lim_{m\to\infty}E[\hat{\theta}_{m}]=\theta$</code>。</p>
</blockquote>
<h3 id="variance-and-standard-error">Variance and Standard Error<a hidden class="anchor" aria-hidden="true" href="#variance-and-standard-error">#</a></h3>
<p>Another property of the estimator that we might want to consider is how much we expect it to vary as a function of the data sample. Just as we computed the expectation of the estimator to determine its bias, we can compute its variance. The variance of an estimator is simply the variance</p>
<p><code>$$ Var(\hat{\theta}) \\ $$</code></p>
<p>where the random variable is the training set. Alternately, the square root of the variance is called the <strong>standard error</strong>, denoted <code>$SE(\hat{\theta})$</code>.</p>
<p>The variance or the standard error of an estimator provides a measure of how we would expect the estimate we compute from data to vary as we independently resample the dataset from the underlying data generating process. Just as we might like an estimator to exhibit low bias we would also like it to have relatively low variance.</p>
<blockquote>
<p>估计量的 <strong>方差(variance)</strong> 或 <strong>标准差(standard error)</strong> 告诉我们，当独立地从潜在的数据生成过程中重采样数据集时，如何期望估计的变化。正如我们希望估计的偏差较小，我们也希望其方差较小。</p>
</blockquote>
<p>When we compute any statistic using a finite number of samples, our estimate of the true underlying parameter is uncertain, in the sense that we could have obtained other samples from the same distribution and their statistics would have been different. The expected degree of variation in any estimator is a source of error that we want to quantify.</p>
<p>The standard error of the mean is given by</p>
<p><code>$$ SE(\hat{\mu}_{m})=\sqrt{Var \left[\frac{1}{m}\sum_{i=1}^{m}x^{(i)}\right]} = \frac{\sigma}{\sqrt{m}} \\ $$</code></p>
<p>where <code>$\sigma^{2}$</code> is the true variance of the samples <code>$x^{i}$</code>. The standard error is often estimated by using an estimate of <code>$\sigma$</code>. Unfortunately, neither the square root of the sample variance nor the square root of the unbiased estimator of the variance provide an unbiased estimate of the standard deviation. Both approaches tend to underestimate the true standard deviation, but are still used in practice. The square root of the unbiased estimator of the variance is less of an underestimate. For large <code>$m$</code>, the approximation is quite reasonable.</p>
<p>The standard error of the mean is very useful in machine learning experiments. We often estimate the generalization error by computing the sample mean of the error on the test set. The number of examples in the test set determines the accuracy of this estimate. Taking advantage of the central limit theorem, which
tells us that the mean will be approximately distributed with a normal distribution, we can use the standard error to compute the probability that the true expectation falls in any chosen interval. For example, the 95% confidence interval centered on the mean <code>$\hat{\mu}_{m}$</code> is</p>
<p><code>$$ (\hat{\mu}_{m}-1.96SE(\hat{\mu}_{m}),\hat{\mu}_{m}+1.96SE(\hat{\mu}_{m})) \\ $$</code></p>
<p>under the normal distribution with mean <code>$\mu_{m}$</code> and variance <code>$SE(\hat{\mu}_{m})^{2}$</code>. In machine learning experiments, it is common to say that algorithm <code>$A$</code> is better than algorithm <code>$B$</code> if the upper bound of the 95% confidence interval for the error of algorithm <code>$A$</code> is less than the lower bound of the 95% confidence interval for the error of algorithm <code>$B$</code>.</p>
<h3 id="trading-off-bias-and-variance-to-minimize-mean-squared-error">Trading off Bias and Variance to Minimize Mean Squared Error<a hidden class="anchor" aria-hidden="true" href="#trading-off-bias-and-variance-to-minimize-mean-squared-error">#</a></h3>
<p>Bias and variance measure two different sources of error in an estimator. Bias measures the expected deviation from the true value of the function or parameter. Variance on the other hand, provides a measure of the deviation from the expected estimator value that any particular sampling of the data is likely to cause.</p>
<p>What happens when we are given a choice between two estimators, one with more bias and one with more variance? How do we choose between them?</p>
<p>The most common way to negotiate this trade-off is to use cross-validation. Empirically, cross-validation is highly successful on many real-world tasks. Alternatively, we can also compare the <strong>mean squared error (MSE)</strong> of the estimates:</p>
<p><code>$$ \begin{align*} MSE &amp;= E[(\hat{\theta}_{m}-\theta)^{2}] \\ &amp;= Bias(\hat{\theta}_{m})^{2} + Var(\hat{\theta}_{m}) \\ \end{align*} $$</code></p>
<p>The MSE measures the overall expected deviation—in a squared error sense— between the estimator and the true value of the parameter <code>$\theta$</code>.</p>
<p>The relationship between bias and variance is tightly linked to the machine learning concepts of capacity, underfitting and overfitting. In the case where generalization error is measured by the MSE (where bias and variance are meaningful components of generalization error), increasing capacity tends to increase variance and decrease bias.</p>
 <div align="center">
   <img src="/img_ML_Basics/ML_Basics_04_Bias_and_Variance.PNG" width=600px/>
 </div>
 <br>
<h3 id="consistency">Consistency<a hidden class="anchor" aria-hidden="true" href="#consistency">#</a></h3>
<p>So far we have discussed the properties of various estimators for a training set of fixed size. Usually, we are also concerned with the behavior of an estimator as the amount of training data grows. In particular, we usually wish that, as the number of data points m in our dataset increases, our point estimates converge to the true value of the corresponding parameters. More formally, we would like that</p>
<p><code>$$ \mathrm{plim}_{m\to\infty}\hat{\theta}_{m}=\theta \\ $$</code></p>
<p>The symbol <code>$\mathrm{plim}$</code> indicates convergence in probability, meaning that for any <code>$\epsilon &gt;0$</code>, <code>$P(|\hat{\theta}_{m}-\theta|&gt; \epsilon)\to 0$</code> as <code>$m \to \infty$</code>. The condition described by equation <code>$\mathrm{plim}_{m\to\infty}\hat{\theta}_{m}=\theta$</code> is known as <strong>consistency</strong>. It is sometimes referred to as weak consistency, with strong consistency referring to the <strong>almost sure</strong> convergence of <code>$\hat{\theta}$</code> to <code>$\theta$</code>. Almost sure convergence of a sequence of random variables <code>$x^{(1)},x^{(2)},\cdots$</code> to a value <code>$x$</code> occurs when <code>$p(\lim_{m\to\infty} x^{(m)} = x) = 1$</code>.</p>
<p>Consistency ensures that the bias induced by the estimator diminishes as the number of data examples grows. However, the reverse is not true—asymptotic unbiasedness does not imply consistency.</p>
<h2 id="maximum-likelihood-estimation">Maximum Likelihood Estimation<a hidden class="anchor" aria-hidden="true" href="#maximum-likelihood-estimation">#</a></h2>
<p>We have seen some definitions of common estimators and analyzed their properties. But where did these estimators come from? Rather than guessing that some function might make a good estimator and then analyzing its bias and variance, we would like to have some principle from which we can derive specific functions that are good estimators for different models.</p>
<p>The most common such principle is the maximum likelihood principle.</p>
<p>Consider a set of m examples <code>$\mathbb{X}=x^{(1)},\cdots,x^{(m)}$</code> drawn independently from the true but unknown data generating distribution <code>$p_{data}(x)$</code>.</p>
<p>Let <code>$p_{model}(x;\theta)$</code> be a parametric family of probability distributions over the same space indexed by <code>$\theta$</code>. In other words, <code>$p_{model}(x;\theta)$</code> maps any configuration <code>$x$</code> to a real number estimating the true probability <code>$p_{data}(x)$</code>.</p>
<p>The maximum likelihood estimator for <code>$\theta$</code> is then defined as</p>
<p><code>$$ \begin{align*} \theta_{ML}&amp;=\arg\max_{\theta}p_{model}(\mathbb{X};\theta) \\ &amp;= \arg\max_{\theta}\prod_{i=1}^{m}p_{model}(x^{(i)};\theta) \\ \end{align*} $$</code></p>
<p>This product over many probabilities can be inconvenient for a variety of reasons. For example, it is prone to numerical underflow. To obtain a more convenient but equivalent optimization problem, we observe that taking the logarithm of the likelihood does not change its arg max but does conveniently transform a product into a sum:</p>
<p><code>$$ \theta_{ML}=\arg\max_{\theta}\sum_{i=1}^{m}\log p_{model}(x^{(i)};\theta) \\ $$</code></p>
<p>Because the <code>$\arg\max$</code> does not change when we rescale the cost function, we can divide by <code>$m$</code> to obtain a version of the criterion that is expressed as an expectation with respect to the empirical distribution <code>$\hat{p}_{data}$</code> defined by the training data:</p>
<p><code>$$ \theta_{ML}=\arg\max_{\theta}\mathbb{E}_{x\sim \hat{p}_{data}}\log p_{model}(x;\theta) \\ $$</code></p>
<h3 id="conditional-log-likelihood-and-mean-squared-error">Conditional Log-Likelihood and Mean Squared Error<a hidden class="anchor" aria-hidden="true" href="#conditional-log-likelihood-and-mean-squared-error">#</a></h3>
<p>The maximum likelihood estimator can readily be generalized to the case where our goal is to estimate a conditional probability <code>$P(y|x;\theta)$</code> in order to predict <code>$y$</code> given <code>$x$</code>. This is actually the most common situation because it forms the basis for most supervised learning. If <code>$X$</code> represents all our inputs and <code>$Y$</code> all our observed targets, then the conditional maximum likelihood estimator is</p>
<p><code>$$ \theta_{ML}=\arg\max_{\theta}P(Y|X;\theta) \\ $$</code></p>
<p>If the examples are assumed to be i.i.d., then this can be decomposed into</p>
<p><code>$$ \theta_{ML}=\arg\max_{\theta}\sum_{i=1}^{m}\log p_{model}(y^{(i)}|x^{(i)};\theta) \\ $$</code></p>
<h3 id="properties-of-maximum-likelihood">Properties of Maximum Likelihood<a hidden class="anchor" aria-hidden="true" href="#properties-of-maximum-likelihood">#</a></h3>
<p>The main appeal of the maximum likelihood estimator is that it can be shown to be the best estimator asymptotically, as the number of examples <code>$m\to\infty$</code>, in terms of its rate of convergence as <code>$m$</code> increases.</p>
<p>Under appropriate conditions, the maximum likelihood estimator has the property of consistency, meaning that as the number of training examples approaches infinity, the maximum likelihood estimate of a parameter converges to the true value of the parameter. These conditions are:</p>
<ul>
<li>The true distribution <code>$p_{data}$</code> must lie within the model family <code>$p_{model}(\cdot;\theta)$</code>. Otherwise, no estimator can recover <code>$p_{data}$</code> .</li>
<li>The true distribution <code>$p_{data}$</code> must correspond to exactly one value of <code>$\theta$</code>. Other- wise, maximum likelihood can recover the correct <code>$p_{data}$</code> , but will not be able to determine which value of <code>$\theta$</code> was used by the data generating processing.</li>
</ul>
<h2 id="bayesian-statistics">Bayesian Statistics<a hidden class="anchor" aria-hidden="true" href="#bayesian-statistics">#</a></h2>
<p>We have discussed <strong>frequentist statistics</strong> and approaches based on estimating a single value of <code>$\theta$</code>, then making all predictions thereafter based on that one estimate. Another approach is to consider all possible values of <code>$\theta$</code> when making a prediction. The latter is the domain of <strong>Bayesian statistics</strong>.</p>
<p>The frequentist perspective is that the true parameter value <code>$\theta$</code> is fixed but unknown, while the point estimate <code>$\hat{\theta}$</code> is a random variable on account of it being a function of the dataset (which is seen as random).</p>
<p>The Bayesian perspective on statistics is quite different. The Bayesian uses probability to reflect degrees of certainty of states of knowledge. The dataset is directly observed and so is not random. On the other hand, the true parameter <code>$\theta$</code> is unknown or uncertain and thus is represented as a random variable.</p>
<blockquote>
<p><strong>频率派(frequentist statistics)</strong> 的视角是真实参数 <code>$\theta$</code> 是未知的定值，而点估计 <code>$\hat{\theta}$</code> 是考虑数据集上函数(可以看作是随机的)的随机变量。 <strong>贝叶斯统计(Bayesian statistics)</strong> 的视角完全不同。贝叶斯用概率反映知识状态的确定性程度。数据 集能够被直接观测到，因此不是随机的。另一方面，真实参数 <code>$\theta$</code> 是未知或不确定的， 因此可以表示成随机变量。</p>
</blockquote>
<p>Before observing the data, we represent our knowledge of <code>$\theta$</code> using the <strong>prior probability distribution</strong>, <code>$p(\theta)$</code> (sometimes referred to as simply “the prior”). Generally, the machine learning practitioner selects a prior distribution that is quite broad (i.e. with high entropy) to reflect a high degree of uncertainty in the value of <code>$\theta$</code> before observing any data. For example, one might assume a priori that <code>$\theta$</code> lies in some finite range or volume, with a uniform distribution. Many priors instead reflect a preference for “simpler” solutions (such as smaller magnitude coefficients, or a function that is closer to being constant).</p>
<p>Now consider that we have a set of data samples <code>$\{x^{(1)},\cdots,x^{(m)}\}$</code>. We can recover the effect of data on our belief about <code>$\theta$</code> by combining the data likelihood <code>$p(x^{(1)},\cdots,x^{(m)}|\theta)$</code> with the prior via Bayes’ rule:</p>
<p><code>$$ p(\theta|x^{(1)},\cdots,x^{(m)})=\frac{p(x^{(1)},\cdots,x^{(m)}|\theta)p(\theta)}{p(x^{(1)},\cdots,x^{(m)})} \\ $$</code></p>
<p>In the scenarios where Bayesian estimation is typically used, the prior begins as a relatively uniform or Gaussian distribution with high entropy, and the observation of the data usually causes the posterior to lose entropy and concentrate around a few highly likely values of the parameters.</p>
<p>Relative to maximum likelihood estimation, Bayesian estimation offers two important differences. First, unlike the maximum likelihood approach that makes predictions using a point estimate of <code>$\theta$</code>, the Bayesian approach is to make predictions using a full distribution over <code>$\theta$</code>. For example, after observing <code>$m$</code> examples, the predicted distribution over the next data sample, <code>$x^{(m+1)}$</code> , is given by</p>
<p><code>$$ p(x^{(m+1)}|x^{(1)},\cdots,x^{(m)})=\int p(x^{(m+1)}|\ \theta)p(\theta \ |x^{(1)},\cdots,x^{(m)})d\theta  \\ $$</code></p>
<p>Here each value of <code>$\theta$</code> with positive probability density contributes to the prediction of the next example, with the contribution weighted by the posterior density itself. After having observed <code>$\{x^{(1)},\cdots,x^{(m)}\}$</code>, if we are still quite uncertain about the value of <code>$\theta$</code>, then this uncertainty is incorporated directly into any predictions we might make.</p>
<p>The second important difference between the Bayesian approach to estimation and the maximum likelihood approach is due to the contribution of the Bayesian prior distribution. The prior has an influence by shifting probability mass density towards regions of the parameter space that are preferred a priori. In practice, the prior often expresses a preference for models that are simpler or more smooth. Critics of the Bayesian approach identify the prior as a source of subjective human judgment impacting the predictions.</p>
<p>Bayesian methods typically generalize much better when limited training data is available, but typically suffer from high computational cost when the number of training examples is large.</p>
<h2 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h2>
<p>[1]  Goodfellow, I., Bengio, Y., &amp; Courville, A. (2016, Nov 18). Deep Learning. <a href="https://www.deeplearningbook.org/contents/ml.html">https://www.deeplearningbook.org/contents/ml.html</a>.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://followb1ind1y.github.io/tags/machine-learning/">Machine Learning</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://followb1ind1y.github.io/posts/deep_learning/01_perceptron_and_backpropagation/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Neural Network: Perceptron and Backpropagation</span>
  </a>
  <a class="next" href="https://followb1ind1y.github.io/posts/applied_math_and_ml_basics/03_numerical_computation_for_ml/">
    <span class="title">Next Page »</span>
    <br>
    <span>[ML Basics] Numerical Computation</span>
  </a>
</nav>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Machine Learning Basics on twitter"
        href="https://twitter.com/intent/tweet/?text=%5bML%20Basics%5d%20Machine%20Learning%20Basics&amp;url=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f04_machine_learning_basics_for_ml%2f&amp;hashtags=MachineLearning">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Machine Learning Basics on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f04_machine_learning_basics_for_ml%2f&amp;title=%5bML%20Basics%5d%20Machine%20Learning%20Basics&amp;summary=%5bML%20Basics%5d%20Machine%20Learning%20Basics&amp;source=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f04_machine_learning_basics_for_ml%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Machine Learning Basics on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f04_machine_learning_basics_for_ml%2f&title=%5bML%20Basics%5d%20Machine%20Learning%20Basics">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Machine Learning Basics on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f04_machine_learning_basics_for_ml%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Machine Learning Basics on whatsapp"
        href="https://api.whatsapp.com/send?text=%5bML%20Basics%5d%20Machine%20Learning%20Basics%20-%20https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f04_machine_learning_basics_for_ml%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [ML Basics] Machine Learning Basics on telegram"
        href="https://telegram.me/share/url?text=%5bML%20Basics%5d%20Machine%20Learning%20Basics&amp;url=https%3a%2f%2ffollowb1ind1y.github.io%2fposts%2fapplied_math_and_ml_basics%2f04_machine_learning_basics_for_ml%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://followb1ind1y.github.io/">Followb1ind1y</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script src="//yihui.org/js/math-code.js"></script>


<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>

</html>
